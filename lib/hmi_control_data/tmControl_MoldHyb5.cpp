/*===========================================================================+
|  Class    : CtmControl_Mold	                                        	 |
|  Task     : Mold Service Function	    	                     			 |
|----------------------------------------------------------------------------|
|  Compile  : G++(GCC)3.2                                                    |
|  Link     : G++(GCC)3.2                                                    |
|  Call     :                                                                |
|----------------------------------------------------------------------------|
|  Author   : James		                                                     |
|  Version  : V1.00                                                          |
|  Creation : 05/11/2008	                                                 |
|  Revision : 05/11/2008  				                                     |
+===========================================================================*/
#include	"tmControl_MoldHyb5.h"
#include	"../../utils.h"
#include	"../../tmdebug.h"
#include	"../../moldControl.h"
#include	"../../commonaction.h"
#include	"../../tmconfig.h"
#include 	"../../tmshmsg.h"
#include 	"../../tmnbmsg.h"
#include	"../../iotable.h"
#include 	<map>
using		namespace std;
IMPLEMENT_DYNCREATE(CtmControl_Mold, CtmControl)
IMPLEMENT_DYNCREATE(CtmControl_MoldHyb5, CtmControl_Mold)

/*===========================================================================+
|           Constants                                                        |
+===========================================================================*/
#define		DATA_MIN_SIZE 			4
#define		MOLDSET_VERSIONS		0x00000003
#define		CURRENT_MOLD_NAME		"MHDR_MODULE_NULL_NULL_MODULENAME"

extern	BOOL	g_biNetStatus;/*JOYCE2013-6-5 9:42:31*/

int		nParallValue[20];
static	char*	g_apszParallID[] = {
	            "MSET_OTHR_OTHR_NULL_W0843",
	            "MSET_OTHR_OTHR_NULL_W0844",
	            "MSET_OTHR_OTHR_NULL_W0845",
	            "MSET_OTHR_OTHR_NULL_W0846",
	            "MSET_OTHR_OTHR_NULL_W0847",
	            "MSET_OTHR_OTHR_NULL_W0848",
	            "MSET_OTHR_OTHR_NULL_W0849",
	            "MSET_OTHR_OTHR_NULL_W084A",
	            "MSET_OTHR_OTHR_NULL_W084B",
	            "MSET_OTHR_OTHR_NULL_W084C",
	            "MSET_OTHR_OTHR_NULL_W084D",
	            "MSET_OTHR_OTHR_NULL_W084E",
	            "MSET_OTHR_OTHR_NULL_W084F",
	            "MSET_OTHR_OTHR_NULL_W0850",
	            "MSET_OTHR_OTHR_NULL_W0853",
	            "MSET_OTHR_OTHR_NULL_W0854",
	            "MSET_OTHR_OTHR_NULL_W0855",
	            "MSET_OTHR_OTHR_NULL_W0856",
            	"MSET_OTHR_OTHR_NULL_W0870",
          		NULL
            };

#ifdef	D_PXA255
#define	MOLD_PATH		"/usr/Data/moldset/"
#else
#define	MOLD_PATH		"/usr/Data/moldset/"
#ifdef	D_3354
#define	MOLD_USB_PATH		"/media/sda1/moldset_55/"
#else
#define	MOLD_USB_PATH		"/mnt/usb/moldset/"
#endif
#endif

#define		BLOCK_DB_PLC_INJECT_SET			308
#define		BLOCK_DB_PLC_DOSING_SET			310
#define		BLOCK_DB_PLC_OTHER_SET			314
#define		BLOCK_DB_PLC_MOLD_SET			304
#define		BLOCK_DB_PLC_TEMPER				315
#define		BLOCK_DB_PLC_AXIS1_SET			289
#define		BLOCK_DB_PLC_AXIS2_SET			292

/*JOYCE2015-11-12 放抓d勖霭鸭痞sx旒舀惆鸭啤Fkernelw拽,放爪苯uぃsSRAM,放抓d把计iHsxF*/
char*	pszMoldset_DB [] =
{
//////////////////////////////////////////////////
///////////////TEMPCARD  Temper SetValue/////////
////////////////////////////////////////////////
"TEMPERCARD1_INTERFACE_LSEG1_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG2_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG3_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG4_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG5_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG6_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG7_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG8_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG9_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG10_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG11_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG12_ABSTRACTSET",

"TEMPERCARD1_INTERFACE_LSEG13_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG14_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG15_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG16_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG17_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG18_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG19_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG20_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG21_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG22_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG23_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG24_ABSTRACTSET",

/*家放]w*/
"TEMPERCARD1_INTERFACE_LSEG25_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG26_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG27_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG28_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG29_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG30_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG31_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG32_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG33_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG34_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG35_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG36_ABSTRACTSET",

"TEMPERCARD1_INTERFACE_LSEG37_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG38_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG39_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG40_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG41_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG42_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG43_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG44_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG45_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG46_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG47_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG48_ABSTRACTSET",

"TEMPERCARD1_INTERFACE_LSEG49_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG50_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG51_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG52_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG53_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG54_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG55_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG56_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG57_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG58_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG59_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG60_ABSTRACTSET",

"TEMPERCARD1_INTERFACE_LSEG61_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG62_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG63_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG64_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG65_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG66_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG67_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG68_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG69_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG70_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG71_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG72_ABSTRACTSET",

"TEMPERCARD1_INTERFACE_LSEG73_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG74_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG75_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG76_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG77_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG78_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG79_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG80_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG81_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG82_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG83_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG84_ABSTRACTSET",

"TEMPERCARD1_INTERFACE_LSEG85_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG86_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG87_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG88_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG89_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG90_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG91_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG92_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG93_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG94_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG95_ABSTRACTSET",
"TEMPERCARD1_INTERFACE_LSEG96_ABSTRACTSET",

/////////////////////////////////////////////
////////////////TEMPCARD Temper Uplimit/////
////////////////////////////////////////////
"TEMPERCARD1_INTERFACE_SSEG1_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG2_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG3_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG4_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG5_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG6_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG7_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG8_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG9_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG10_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG11_UPLIMIT",
//"TEMPERCARD1_INTERFACE_SSEG12_UPLIMIT",  /*o放WU,妮_MACH,蛤55翰韦@*/

"TEMPERCARD1_INTERFACE_SSEG13_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG14_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG15_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG16_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG17_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG18_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG19_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG20_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG21_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG22_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG23_UPLIMIT",
//"TEMPERCARD1_INTERFACE_SSEG24_UPLIMIT",   /*o放WU,妮_MACH,蛤55翰韦@*/

/*家放W熬t*/
"TEMPERCARD1_INTERFACE_SSEG25_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG26_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG27_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG28_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG29_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG30_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG31_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG32_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG33_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG34_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG35_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG36_UPLIMIT",

"TEMPERCARD1_INTERFACE_SSEG37_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG38_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG39_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG40_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG41_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG42_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG43_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG44_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG45_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG46_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG47_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG48_UPLIMIT",

"TEMPERCARD1_INTERFACE_SSEG49_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG50_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG51_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG52_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG53_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG54_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG55_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG56_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG57_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG58_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG59_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG60_UPLIMIT",

"TEMPERCARD1_INTERFACE_SSEG61_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG62_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG63_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG64_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG65_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG66_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG67_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG68_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG69_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG70_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG71_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG72_UPLIMIT",

"TEMPERCARD1_INTERFACE_SSEG73_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG74_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG75_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG76_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG77_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG78_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG79_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG80_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG81_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG82_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG83_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG84_UPLIMIT",

"TEMPERCARD1_INTERFACE_SSEG85_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG86_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG87_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG88_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG89_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG90_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG91_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG92_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG93_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG94_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG95_UPLIMIT",
"TEMPERCARD1_INTERFACE_SSEG96_UPLIMIT",

//////////////////////////////////////////////////
//////////////TEMPCARD Temper Downlimit///////////
/////////////////////////////////////////////////
"TEMPERCARD1_INTERFACE_SSEG1_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG2_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG3_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG4_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG5_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG6_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG7_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG8_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG9_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG10_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG11_DOWNLIMIT",
//"TEMPERCARD1_INTERFACE_SSEG12_DOWNLIMIT",/*o放WU,妮_MACH,蛤55翰韦@*/

"TEMPERCARD1_INTERFACE_SSEG13_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG14_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG15_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG16_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG17_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG18_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG19_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG20_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG21_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG22_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG23_DOWNLIMIT",
//"TEMPERCARD1_INTERFACE_SSEG24_DOWNLIMIT", /*o放WU,妮_MACH,蛤55翰韦@*/

/*家放U熬t*/
"TEMPERCARD1_INTERFACE_SSEG25_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG26_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG27_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG28_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG29_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG30_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG31_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG32_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG33_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG34_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG35_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG36_DOWNLIMIT",

"TEMPERCARD1_INTERFACE_SSEG37_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG38_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG39_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG40_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG41_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG42_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG43_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG44_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG45_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG46_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG47_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG48_DOWNLIMIT",

"TEMPERCARD1_INTERFACE_SSEG49_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG50_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG51_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG52_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG53_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG54_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG55_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG56_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG57_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG58_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG59_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG60_DOWNLIMIT",

"TEMPERCARD1_INTERFACE_SSEG61_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG62_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG63_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG64_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG65_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG66_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG67_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG68_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG69_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG70_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG71_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG72_DOWNLIMIT",

"TEMPERCARD1_INTERFACE_SSEG73_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG74_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG75_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG76_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG77_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG78_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG79_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG80_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG81_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG82_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG83_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG84_DOWNLIMIT",

"TEMPERCARD1_INTERFACE_SSEG85_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG86_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG87_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG88_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG89_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG90_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG91_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG92_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG93_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG94_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG95_DOWNLIMIT",
"TEMPERCARD1_INTERFACE_SSEG96_DOWNLIMIT",

//////////////////////////////////////////////////
//////////////TEMPCARD MoldTemper HeatSpeed///////
/////////////////////////////////////////////////
/*家放[荐tv匡拒兜0=ぃノ1=ㄏノ*/
"TEMPERCARD1_INTERFACE_WSEG25_USE",
"TEMPERCARD1_INTERFACE_WSEG26_USE",
"TEMPERCARD1_INTERFACE_WSEG27_USE",
"TEMPERCARD1_INTERFACE_WSEG28_USE",
"TEMPERCARD1_INTERFACE_WSEG29_USE",
"TEMPERCARD1_INTERFACE_WSEG30_USE",
"TEMPERCARD1_INTERFACE_WSEG31_USE",
"TEMPERCARD1_INTERFACE_WSEG32_USE",
"TEMPERCARD1_INTERFACE_WSEG33_USE",
"TEMPERCARD1_INTERFACE_WSEG34_USE",
"TEMPERCARD1_INTERFACE_WSEG35_USE",
"TEMPERCARD1_INTERFACE_WSEG36_USE",

"TEMPERCARD1_INTERFACE_WSEG37_USE",
"TEMPERCARD1_INTERFACE_WSEG38_USE",
"TEMPERCARD1_INTERFACE_WSEG39_USE",
"TEMPERCARD1_INTERFACE_WSEG40_USE",
"TEMPERCARD1_INTERFACE_WSEG41_USE",
"TEMPERCARD1_INTERFACE_WSEG42_USE",
"TEMPERCARD1_INTERFACE_WSEG43_USE",
"TEMPERCARD1_INTERFACE_WSEG44_USE",
"TEMPERCARD1_INTERFACE_WSEG45_USE",
"TEMPERCARD1_INTERFACE_WSEG46_USE",
"TEMPERCARD1_INTERFACE_WSEG47_USE",
"TEMPERCARD1_INTERFACE_WSEG48_USE",

"TEMPERCARD1_INTERFACE_WSEG49_USE",
"TEMPERCARD1_INTERFACE_WSEG50_USE",
"TEMPERCARD1_INTERFACE_WSEG51_USE",
"TEMPERCARD1_INTERFACE_WSEG52_USE",
"TEMPERCARD1_INTERFACE_WSEG53_USE",
"TEMPERCARD1_INTERFACE_WSEG54_USE",
"TEMPERCARD1_INTERFACE_WSEG55_USE",
"TEMPERCARD1_INTERFACE_WSEG56_USE",
"TEMPERCARD1_INTERFACE_WSEG57_USE",
"TEMPERCARD1_INTERFACE_WSEG58_USE",
"TEMPERCARD1_INTERFACE_WSEG59_USE",
"TEMPERCARD1_INTERFACE_WSEG60_USE",

"TEMPERCARD1_INTERFACE_WSEG61_USE",
"TEMPERCARD1_INTERFACE_WSEG62_USE",
"TEMPERCARD1_INTERFACE_WSEG63_USE",
"TEMPERCARD1_INTERFACE_WSEG64_USE",
"TEMPERCARD1_INTERFACE_WSEG65_USE",
"TEMPERCARD1_INTERFACE_WSEG66_USE",
"TEMPERCARD1_INTERFACE_WSEG67_USE",
"TEMPERCARD1_INTERFACE_WSEG68_USE",
"TEMPERCARD1_INTERFACE_WSEG69_USE",
"TEMPERCARD1_INTERFACE_WSEG70_USE",
"TEMPERCARD1_INTERFACE_WSEG71_USE",
"TEMPERCARD1_INTERFACE_WSEG72_USE",

"TEMPERCARD1_INTERFACE_WSEG73_USE",
"TEMPERCARD1_INTERFACE_WSEG74_USE",
"TEMPERCARD1_INTERFACE_WSEG75_USE",
"TEMPERCARD1_INTERFACE_WSEG76_USE",
"TEMPERCARD1_INTERFACE_WSEG77_USE",
"TEMPERCARD1_INTERFACE_WSEG78_USE",
"TEMPERCARD1_INTERFACE_WSEG79_USE",
"TEMPERCARD1_INTERFACE_WSEG80_USE",
"TEMPERCARD1_INTERFACE_WSEG81_USE",
"TEMPERCARD1_INTERFACE_WSEG82_USE",
"TEMPERCARD1_INTERFACE_WSEG83_USE",
"TEMPERCARD1_INTERFACE_WSEG84_USE",

"TEMPERCARD1_INTERFACE_WSEG85_USE",
"TEMPERCARD1_INTERFACE_WSEG86_USE",
"TEMPERCARD1_INTERFACE_WSEG87_USE",
"TEMPERCARD1_INTERFACE_WSEG88_USE",
"TEMPERCARD1_INTERFACE_WSEG89_USE",
"TEMPERCARD1_INTERFACE_WSEG90_USE",
"TEMPERCARD1_INTERFACE_WSEG91_USE",
"TEMPERCARD1_INTERFACE_WSEG92_USE",
"TEMPERCARD1_INTERFACE_WSEG93_USE",
"TEMPERCARD1_INTERFACE_WSEG94_USE",
"TEMPERCARD1_INTERFACE_WSEG95_USE",
"TEMPERCARD1_INTERFACE_WSEG96_USE",

//////////////////////////////////////////////////
//////////////TEMPCARD MoldTemper BANLANCE///////
/////////////////////////////////////////////////
/*家放UqPB[放匡兜*/
"TEMPERCARD1_INTERFACE_WSEG25_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG26_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG27_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG28_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG29_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG30_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG31_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG32_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG33_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG34_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG35_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG36_BANLANCE_HEATUSE",

"TEMPERCARD1_INTERFACE_WSEG37_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG38_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG39_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG40_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG41_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG42_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG43_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG44_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG45_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG46_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG47_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG48_BANLANCE_HEATUSE",

"TEMPERCARD1_INTERFACE_WSEG49_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG50_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG51_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG52_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG53_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG54_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG55_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG56_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG57_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG58_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG59_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG60_BANLANCE_HEATUSE",

"TEMPERCARD1_INTERFACE_WSEG61_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG62_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG63_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG64_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG65_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG66_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG67_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG68_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG69_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG70_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG71_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG72_BANLANCE_HEATUSE",

"TEMPERCARD1_INTERFACE_WSEG73_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG74_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG75_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG76_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG77_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG78_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG79_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG80_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG81_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG82_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG83_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG84_BANLANCE_HEATUSE",

"TEMPERCARD1_INTERFACE_WSEG85_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG86_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG87_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG88_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG89_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG90_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG91_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG92_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG93_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG94_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG95_BANLANCE_HEATUSE",
"TEMPERCARD1_INTERFACE_WSEG96_BANLANCE_HEATUSE",

//////////////////////////////////////////////////
//////////////TEMPCARD MoldTemper KP//////////////
/////////////////////////////////////////////////
/*家放UqKP*/
"TEMPERCARD1_INTERFACE_WSEG25_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG26_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG27_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG28_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG29_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG30_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG31_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG32_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG33_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG34_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG35_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG36_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG37_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG38_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG39_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG40_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG41_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG42_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG43_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG44_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG45_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG46_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG47_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG48_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG49_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG50_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG51_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG52_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG53_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG54_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG55_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG56_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG57_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG58_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG59_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG60_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG61_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG62_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG63_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG64_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG65_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG66_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG67_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG68_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG69_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG70_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG71_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG72_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG73_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG74_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG75_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG76_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG77_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG78_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG79_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG80_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG81_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG82_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG83_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG84_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG85_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG86_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG87_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG88_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG89_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG90_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG91_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG92_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG93_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG94_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG95_PIDSET_KP",
"TEMPERCARD1_INTERFACE_WSEG96_PIDSET_KP",

//////////////////////////////////////////////////
//////////////TEMPCARD MoldTemper KI//////////////
/////////////////////////////////////////////////
/*家放UqKI*/
"TEMPERCARD1_INTERFACE_WSEG25_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG26_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG27_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG28_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG29_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG30_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG31_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG32_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG33_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG34_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG35_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG36_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG37_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG38_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG39_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG40_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG41_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG42_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG43_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG44_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG45_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG46_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG47_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG48_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG49_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG50_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG51_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG52_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG53_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG54_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG55_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG56_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG57_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG58_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG59_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG60_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG61_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG62_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG63_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG64_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG65_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG66_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG67_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG68_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG69_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG70_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG71_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG72_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG73_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG74_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG75_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG76_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG77_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG78_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG79_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG80_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG81_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG82_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG83_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG84_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG85_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG86_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG87_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG88_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG89_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG90_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG91_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG92_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG93_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG94_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG95_PIDSET_KI",
"TEMPERCARD1_INTERFACE_WSEG96_PIDSET_KI",

//////////////////////////////////////////////////
//////////////TEMPCARD MoldTemper KD//////////////
/////////////////////////////////////////////////
/*家放UqKD*/
"TEMPERCARD1_INTERFACE_WSEG25_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG26_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG27_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG28_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG29_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG30_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG31_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG32_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG33_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG34_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG35_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG36_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG37_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG38_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG39_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG40_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG41_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG42_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG43_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG44_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG45_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG46_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG47_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG48_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG49_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG50_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG51_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG52_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG53_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG54_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG55_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG56_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG57_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG58_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG59_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG60_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG61_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG62_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG63_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG64_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG65_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG66_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG67_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG68_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG69_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG70_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG71_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG72_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG73_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG74_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG75_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG76_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG77_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG78_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG79_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG80_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG81_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG82_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG83_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG84_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG85_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG86_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG87_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG88_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG89_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG90_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG91_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG92_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG93_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG94_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG95_PIDSET_KD",
"TEMPERCARD1_INTERFACE_WSEG96_PIDSET_KD",

/*\嗫锒*/
"SYSX_TEMPERMOLD_HEATERON_NULL_MOLDHEATOPTION",    /*家放匡拒(`}闽)*/
"M3_CONF_TEMPERCARD_MOLD_HEATERWARM_HALF_OPTION",  /*家放O放\*/
"M3_CONF_TEMPERCARD_MOLD_HEATERWARM_DEGREE",       /*家放O放放*/
"M3_CONF_TEMPERCARD_MOLD_SOFTENABLE_OPTION",       /*家放n币笆放*/
"M3_CONF_TEMPERCARD_MOLD_SOFTENABLE_TIME",         /*家放n币笆啥*/
"M3_CONF_TEMPERCARD_MOLD_SENSOR_TYPE",             /*家放P放u摸*/
"M3_CONF_TEMPERCARD_HEATE_TYPE1",                  /*家放[荐摸*/
"M3_CONF_TEMPERCARD_HEATE_TYPE2",                  /*家放[荐摸*/
"M3_CONF_TEMPERCARD_MOLD_BALANCEHEART_OPTION",     /*家放PB[放\*/
"M3_CONF_TEMPERCARD_MOLD_BALANCEHEART_DEGREE",     /*家放PB[放放*/
"",

};

int u_nBlockIDs[] = 
{
	//BLOCK_DB_PLC_INJECT_SET,
	//BLOCK_DB_PLC_DOSING_SET,
	//BLOCK_DB_PLC_OTHER_SET,
	//BLOCK_DB_PLC_MOLD_SET,
	//BLOCK_DB_PLC_TEMPER,
	//BLOCK_DB_PLC_AXIS1_SET,
	//BLOCK_DB_PLC_AXIS2_SET,
	//BLOCK_MACHINE_ID,
//	BLOCK_MOLDSETX_ID,	
	437, // BLOCK_PICKER_RECIPE_ID xs弄 毙旧 笆@
//	438, // BLOCK_PICKER_MACHINE_ID xs弄 诀c把计
	//BLOCK_NEWMOLDSET2_ID,
	//BLOCK_NEWMOLDSET3_ID,
	//DB_PLC_EJECT_SET,
	//DB_PLC_INJECT_SET,
	//DB_PLC_DOSING_SET,
	//DB_PLC_CARRIAGE_SET,
	//DB_PLC_OTHER_SET,
	//DB_PLC_TEMPER_SET
};
/*===========================================================================+
|           Type	                                                         |
+===========================================================================*/
tmBlockInfo CtmControl_Mold::m_aBlockInfo[] =
{
	{BLOCK_ZSET_ID				,ID_ZEROSET_FILE},
	{BLOCK_NEWPOWERMATCH_ID		,ID_DATABLE_FILE},
	{BLOCK_MACHINE_ID			,ID_MACHINE_FILE},     //Sunny<20070911><<<<<
	{BLOCK_MACHINEB_ID			,ID_MACHINEB_FILE},
	{BLOCK_NEWPOWERMATCH_MACH_ID,ID_DATABLE_MACH_FILE},
	{BLOCK_MACHINE_MACH_ID		,ID_MACHINE_MACH_FILE},
	{BLOCK_MACHINEB_MACH_ID		,ID_MACHINEB_MACH_FILE},
	{BLOCK_SYSTEMX_ID			,ID_SYSTEMX_FILE}, 
	{BLOCK_USERM_ID				,ID_USERM_FILE}
	//{BLOCK_MACHINE_ID,      ID_VERSION_FILE},
	//{BLOCK_MACHINE_ID,      ID_DEFAULTVALUE_FILE},
	//{BLOCK_MACHINE_ID,      ID_MINVALUE_FILE},
	//{BLOCK_MACHINE_ID,      ID_MAXVALUE_FILE}
	
};
/*===========================================================================+
|           Global variable                                                  |
+===========================================================================*/

/*===========================================================================+
|           Function implementation                                          |
+===========================================================================*/	
/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::CtmControl_Mold()				             |
|  Task     :  CtmControl_Moldcyㄧ计                                       |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:                           -                                    |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
CtmControl_Mold::CtmControl_Mold(): CtmControl()
{
	memset(m_pszMoldSetPath, 0, sizeof(m_pszMoldSetPath));
	m_nMaxMoldSet 	= 0;
	m_nMoldSetSize	= 0;
	m_pContent 		= NULL;
	m_nBlockIndex	= 0;
	m_dwMoldIDCount	= 0;
	m_wGroupCount	= 0;
	memset(m_lMoldID,0,sizeof(m_lMoldID));
	memset(m_StartID,0,sizeof(m_StartID));
	strcpy(m_pszMoldSetPath, MOLD_PATH);
}
/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::~CtmControl_Mold()				             |
|  Task     :  CtmControl_MoldRcㄧ计                                      |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:                           -                                    |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
CtmControl_Mold::~CtmControl_Mold()
{
		
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::CreateSelf()				             	 |
|  Task     :  Initialize Error Service                                      |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:                           -                                    |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
int		CtmControl_Mold::CreateSelf()
{
	//InitControl();
	return 0;	
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::FreeSelf()				             	     |
|  Task     :  Relase Error Service                                          |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:                           -                                    |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
int		CtmControl_Mold::FreeSelf()
{
	if (m_pContent != NULL)
	{
		delete []m_pContent;
		m_pContent = NULL;
	}
	if (m_pHeads != NULL)
	{
		delete []m_pHeads;
		m_pHeads = NULL;
	}
	return 0;	
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::AddControl(void *pParas[])  	     			 |
|  Task     :  Save Error Record to sram and show promp	                     |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   WORD   pParas[0]        - 		                   			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
BOOL	CtmControl_Mold::AddControl(void *pParas[])
{
	
	return TRUE;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::ModifyControl(void *pParas[])  	     		 |
|  Task     :  Modify Error Message 					                     |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   WORD   pParas[0]        - 		                  			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
BOOL	CtmControl_Mold::ModifyControl(void *pParas[])
{
	return FALSE;	
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::FindControl(void *pParas[], void *pFindPara) |
|  Task     :  Search Error Message 					                     |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   void *   pFindPara      - 			               			 |
|               void *pParas[]          - sx穰^耗党T                 |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
BOOL	CtmControl_Mold::FindControl(void *pParas[], void *pFindPara)
{
	
	return TRUE;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::DeleteControl(void *pDeletePara)             |
|  Task     :  Clear All Error Message 					                     |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   void *pDeletePara       - 		                   			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
BOOL	CtmControl_Mold::DeleteControl(void *pDeletePara)
{
	
	return TRUE;	
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::FixControl(void *pFixPara)		             |
|  Task     :  Fix Error Message 					                     	 |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   void *pFixPara          -                        			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
BOOL	CtmControl_Mold::FixControl(void *pFixPara)
{
	                                                                                                              
	return TRUE;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::InitControl()					             |
|  Task     :  Init Error Message 					                     	 |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
void	CtmControl_Mold::InitControl()
{
	
    m_nBlockIndex = -1;
    m_nDataType = ID_STORAGE_NOFILE;
	
	m_pContent = NULL;
	m_pHeads = NULL;
	char*	pszTemp = NULL;
	m_nCurrentIndex = g_pDatabase->GetIndex(CURRENT_MOLD_NAME);
	pszTemp = g_pDatabase->Reads(m_nCurrentIndex);
	//printf("CtmControl_Mold::InitControl()  pszTemp=%s\n",pszTemp);
	//wprintf(L"%s\n",(const wchar_t*)pszTemp);
	if (pszTemp != NULL)
	{
		strncpy(m_szCurrentMoldName, pszTemp, g_pDatabase->Read(CURRENT_MOLD_NAME).DataType.wLength);//sizeof(m_szCurrentMoldName));
	//printf("CtmControl_Mold::InitControl()  m_szCurrentMoldName=%s\n",m_szCurrentMoldName);
	//printf("CtmControl_Mold::InitControl()  wLength=%d\n",g_pDatabase->Read(CURRENT_MOLD_NAME).DataType.wLength);
	}
	else
	{
		strcpy(m_szCurrentMoldName, "Default");
	}
	//printf(".............................<<<<<<<<<<<<<<<<<<<<<<<<<\n");
	m_nMoldSetSize = CalculateNewSize();	//	need to calculate size from yang's block to calculate
	//printf("m_nMoldSetSize=%d\n",m_nMoldSetSize);	
	m_nMaxMoldSet = CtmConfig::GetInstance()->GetMoldSetMaxNum();
    if (m_nMaxMoldSet > 0) 
    {
        m_pHeads = new DB_MOLDHDR[m_nMaxMoldSet];
        m_pContent = new BYTE[m_nMoldSetSize];
        memset(m_pHeads, 0, sizeof(DB_MOLDHDR) * m_nMaxMoldSet);
        memset(m_pContent, 0, sizeof(m_nMoldSetSize));
    }
}

/*---------------------------------------------------------------------------+
|  Function :CtmControl_Mold::Read(DB_MOLDHDR MoldSetHead, tmStorageType StorageType)|
|  Task     :弄w杭舀愀戤                                              |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                                                                |
+---------------------------------------------------------------------------*/
BOOL	CtmControl_Mold::Read(DB_MOLDHDR MoldSetHead, tmStorageType StorageType)
{
    BOOL	bResult = FALSE;
    bResult = (MoldSetHead.acID[0] != '\0');

    if (bResult) 
    {
        int nRecord = 0;
        nRecord = Find(MoldSetHead, StorageType);
        if (nRecord > 0) 	/*豹OWsb赣家ㄣ*/ 
        {
            bResult = Read(nRecord, StorageType);
        }
        else bResult = FALSE;
    }

    return bResult;
}

/*---------------------------------------------------------------------------+
|  Function :CtmControl_Mold::Read(int nIndex, tmStorageType StorageType)    |
|  Task     :弄w杭舀愀戤                                              |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                                                                |
+---------------------------------------------------------------------------*/
BOOL	CtmControl_Mold::Read(int nIndex, tmStorageType StorageType)
{
    BOOL    bResult = FALSE;
    int     nCount = 0;
    nCount = m_pMoldSetFile->GetInstance()->ReadRecord(ID_MOLDSET_SRAMFILE, nIndex, m_pContent, StorageType);
    bResult = (nCount > 0);
    if (bResult) 
    {
        memcpy(&m_Head, m_pContent, sizeof(m_Head));

        if(g_biNetStatus)/*JOYCE2013-6-5 9:43:17*/
        {
        	memcpy(g_MoldHead.acID, m_Head.acID, sizeof(m_Head.acID));	//2013-1-15  iNet  弄杭舀   
    			memcpy(g_MoldHead.szMaterial, m_Head.szMaterial, sizeof(m_Head.szMaterial));
    			memcpy(g_MoldHead.szColor, m_Head.szColor,sizeof(m_Head.szColor));
    			SendMsg(MSG_SH_REV_INET_MOLD_LIMIT, 0, 0, NULL);	//2013-1-15  ビ叫家ㄣWU 
    			g_biNetLimit  = FALSE;	//L家ㄣWU 
    		}

        if (m_Head.acID[0] == '\0') 
        {
            bResult = FALSE;
        }
    }
    return bResult;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::Save(DB_MOLDHDR MoldSetHead, tmStorageType StorageType)|
|  Task     :OsSw杭舀愀戤                                              |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                                                                |
+---------------------------------------------------------------------------*/
BOOL	CtmControl_Mold::Save(DB_MOLDHDR MoldSetHead, tmStorageType StorageType)
{
	BOOL	bResult = FALSE;
    bResult = (MoldSetHead.acID[0] != '\0');

	//printf("CtmControl_Mold::Save \n");
	if (bResult)
	{
		int       nRecord = Find(MoldSetHead, StorageType);
		memcpy(m_pContent, &MoldSetHead, sizeof(DB_MOLDHDR));
		if (nRecord > 0)		//	exist, and override
		{
			//	fans modiy 2009-4-15 9:49:10
			SendMsg(MSG_MOLDSET_OVERWRITE, nRecord, StorageType, NULL);
			//if (g_bFindMoldSetMsg)
			//	MsgBox(g_MultiLanguage["VM_MLD_OVERWRITE"], tmFT_CODE_TECH);
			if(g_bMsgBoxFlag)		//James add 2008/7/22 莉omsgbox涵取AMwO_滦\家舱
				bResult = Save(nRecord, StorageType);
		}
		else 					//	append
		{
			nRecord = FindFree(StorageType);
			SendMsg(MSG_MOLDSET_ADD, nRecord, StorageType, NULL);	//	fans add 2009-4-15 9:49:56
			if (nRecord > 0)
			{
				bResult = Save(nRecord, StorageType);
			}
			else bResult = FALSE;
		}
	}
	return bResult;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::Save(int nIndex,tmStorageType StorageType)    |
|  Task     :OsSw杭舀愀戤                                              |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                                                                |
+---------------------------------------------------------------------------*/
BOOL	CtmControl_Mold::Save(int nIndex,tmStorageType StorageType)
{
	BOOL	bResult = FALSE;
	int nCount = m_pMoldSetFile->GetInstance()->WriteRecord(ID_MOLDSET_SRAMFILE, nIndex,
                                               m_pContent,StorageType);
    bResult = (nCount > 0);
    return bResult;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::Delete(DB_MOLDHDR MoldSetHead, tmStorageType StorageType)|
|  Task     :R埃Sw杭舀愀戤                                              |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                                                                |
+---------------------------------------------------------------------------*/
BOOL	CtmControl_Mold::Delete(DB_MOLDHDR MoldSetHead, tmStorageType StorageType)
{
    BOOL    bResult = FALSE;
    if (MoldSetHead.acID[0] != '\0') 
    {
        bResult = TRUE;
    }

    if (bResult) 
    {
        bResult = !(strcmp(MoldSetHead.acID, m_szCurrentMoldName) == 0);
    }
    
	int nRecord = Find(MoldSetHead, StorageType);
    if (bResult) 
    {
        if (nRecord > 0)
        {
            Delete(nRecord, StorageType);
        }
    }
    else 
    {
    	#ifdef	D_PXA270
    	if( StorageType != STORAGE_TYPE_USB )
    	#else
    	if( StorageType != STORAGE_TYPE_MMCARD )
    	#endif
    	{
    		//	fans modify 2009-4-15 9:51:58
    		SendMsg(MSG_MOLDSET_DEL_CUR, 0, StorageType, NULL);
        	//MsgBox(g_MultiLanguage["VM_MOLD_DELETE_CURRENT"], tmFT_CODE_TECH);
        }
        else		//James add 秆Mぃ唰R埃MMCd江暴M豹OPW杭舀 2007/12/11 03:00Uと
        {
        	if (nRecord > 0)
	        {
	            Delete(nRecord, StorageType);
	        }	
        }
    }

    return bResult;

}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::GetCurrentMold()                              |
|  Task     : 莉讽e杭舀悝W嘿                                             |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   : 讽e杭舀悝W嘿                                                 |
+---------------------------------------------------------------------------*/
char*	CtmControl_Mold::GetCurrentMold()
{
	char*	pszTemp = NULL;
	m_nCurrentIndex = g_pDatabase->GetIndex(CURRENT_MOLD_NAME);
	pszTemp = g_pDatabase->Reads(m_nCurrentIndex);
	//printf("%s dataIndex = %d\n", CURRENT_MOLD_NAME, m_nCurrentIndex);
	
	if (pszTemp != NULL)
	{
		strncpy(m_szCurrentMoldName, pszTemp, sizeof(m_szCurrentMoldName));
	}
	else
	{
		strcpy(m_szCurrentMoldName, "IMCS");
	}
	
	return m_szCurrentMoldName;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::Delete(int nIndex,tmStorageType StorageType)  |
|  Task     : R埃Sw杭舀愀戤    ㄤセ借ONm_Headい害W嘿]mNULL       |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   : O_wgΘ\R埃:TRUE/FALSE                                    |
+---------------------------------------------------------------------------*/
BOOL	CtmControl_Mold::Delete(int nIndex,tmStorageType StorageType)
{
    BOOL	bResult = FALSE;
    DB_MOLDHDR  TempHead;

    memset(&TempHead, 0, sizeof(TempHead));

    bResult = m_pMoldSetFile->GetInstance()->WriteRecord(ID_MOLDSET_SRAMFILE, nIndex, &TempHead, 
				sizeof(TempHead), StorageType) > 0;
    return bResult;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::FindFree(tmStorageType StorageType)           |
|  Task     : dтゅンい邯啪l害旄m,ㄓMwOs戈痞bゅンい害旄m            |
|             旄m歉,pGO0焊塥愆SΤт    		                     |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   : 旄m歉,pGO0焊塥愆SΤт                               |
+---------------------------------------------------------------------------*/
int		CtmControl_Mold::FindFree(tmStorageType StorageType)
{
	int nResult = 0;
    DB_MOLDHDR  TempHead;
	do
	{
        memset(&TempHead, 0, sizeof(TempHead));
		nResult++;
		if (m_pMoldSetFile->GetInstance()->ReadRecord(ID_MOLDSET_SRAMFILE, nResult, 
                                                      &TempHead, sizeof(TempHead),StorageType) <= 0)
			break;
	}while (TempHead.acID[0] != '\0' && nResult <= m_nMaxMoldSet);
	
	if (nResult > m_nMaxMoldSet && TempHead.acID[0] != '\0') nResult = 0;
	return nResult;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::Find(DB_MOLDHDR MoldSetHead, tmStorageType	StorageType)|
|  Task     : dтSw杭舀愀戤         			                         |
|             戈篇骇歉,pGO0焊塥愆SΤт		                     |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
int		CtmControl_Mold::Find(DB_MOLDHDR MoldSetHead, tmStorageType	StorageType)
{
	
	int	nResult = 0;
	DB_MOLDHDR	TempHead;
	memset(&TempHead, 0, sizeof(TempHead));
	
	for (int i = 0; i <  m_nMaxMoldSet; i++)
	{
		if (m_pMoldSetFile->GetInstance()->ReadRecord(ID_MOLDSET_SRAMFILE, i + 1, &TempHead, 
					sizeof(TempHead), StorageType) <= 0)
		{
			break;
		}
		
		if ((strcmp(TempHead.acID, MoldSetHead.acID) == 0))
		{
			nResult = i + 1;
			break;
		}
	}
	return nResult;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::GetMoldSetHead()                              |
|  Task     : 莉oY         			                                     |
|             L阶OOs临OW,ぇ岐喊失@常惠nㄏノ赣ㄧ计ㄓ莉YH		 |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
DB_MOLDHDR*	CtmControl_Mold::GetMoldSetHead()
{
	//printf("CtmControl_Mold m_Head\n");
	return	&m_Head;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::GetMoldSetHead(int nStart, int Num, tmStorageType StorageType)|
|  Task     : 莉oYHЪ撇         			                             |
|             盲／喃O靡bo飒憨姚倡HГ，蔼,歃]OΤi啜猫SΤOs        |
| nStart + Num痈戤 A o妓и瘫N|o飓岘豹韩HД场蔼                   |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
DB_MOLDHDR*	CtmControl_Mold::GetMoldSetHead(int nStart, int Num, tmStorageType StorageType)
{
	//printf("CtmControl_Mold::GetMoldSetHead \n");
	int	nSize = sizeof(DB_MOLDHDR);
	memset(m_pHeads, 0, nSize * m_nMaxMoldSet);
	
	if (Num > m_nMaxMoldSet) Num = m_nMaxMoldSet;
	if (nStart <= 0) nStart = 1;
	
	int	j = 0;
	
	for (int i = nStart; i <= m_nMaxMoldSet; i++)
	{
		if (m_pMoldSetFile->GetInstance()->ReadRecord(ID_MOLDSET_SRAMFILE, i, m_pHeads + j, nSize, 0,
				StorageType) <= 0) 
		{
			(m_pHeads + j)->acID[0] = '\0';
			break;
		}
		
		if ((m_pHeads + j)->acID[0] != '\0')
			j++;
		
		if (j >= Num)	break;
	}
	return	m_pHeads;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::GetMoldSetContent()                           |
|  Task     : 莉oYH         				                             |
|             L阶OOs临OW,ぇ岐喊失@常惠nㄏノ赣ㄧ计ㄓ莉ずeH    |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
BYTE*	CtmControl_Mold::GetMoldSetContent()
{
	return	m_pContent;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::GetMaxMoldSetNum()                            |
|  Task     : 莉す\Os嵛ㄣ撼踏j计ヘ         				             |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
int		CtmControl_Mold::GetMaxMoldSetNum()
{
	return	m_nMaxMoldSet;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::GetMoldSetNum(tmStorageType	StorageType)     |
|  Task     : 莉{bOs嵛ㄣ计ヘ              				             |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
int		CtmControl_Mold::GetMoldSetNum(tmStorageType	StorageType)
{
	int	nResult = 0;
    DB_MOLDHDR  TempHead;

	for (int i = 1; i <= m_nMaxMoldSet; i++)
	{
        memset(&TempHead, 0, sizeof(TempHead));
		if (m_pMoldSetFile->GetInstance()->ReadRecord(ID_MOLDSET_SRAMFILE, i, &TempHead, 
                                                      sizeof(TempHead), StorageType) <= 0) 
            break;
		if (TempHead.acID[0] != '\0') 
		{
			nResult++;
		}
	}
	return	nResult;
}


/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::SaveToCurrentMold(DB_MOLDHDR MoldSetHead, tmStorageType StorageType )  |
|  Task     : oe讽e家舱戈屁欹D诀              				             |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
BOOL CtmControl_Mold::SaveToCurrentMold(DB_MOLDHDR MoldSetHead, tmStorageType StorageType ) 
{
	printf("CtmControl_Mold::SaveToCurrentMold()\n");
	BOOL    bResult = FALSE;

    bResult = Read(MoldSetHead, StorageType);
    //printf("out 111111:%x\n");
    if (bResult) 
    {
    	g_pBlock->GetBlock(m_pContent, BLOCK_MOLDSETX_ID);   //  From BlockBuffer to Database
    	  //printf("out COMM_SENDCONTROLMACHINE:%x\n",COMM_SENDCONTROLMACHINE);

      if(g_ptaskdsp != NULL)	
      {
      	g_ptaskdsp->WriteValue(COMM_SENDCONTROLMOLDSET);//if(g_ptaskrs232 != NULL)	g_ptaskrs232->SendControlMoldset();		
        		if (CtmConfig::GetInstance()->GetMachineType() & MACHINE_TYPE_OIL_DC)
        			g_ptaskdsp->WriteValue(COMM_SENDCONTROLMOLDSETB);
    	}
    	//if(g_ptaskCom2dsp != NULL) g_ptaskCom2dsp->WriteValue(COMM_SENDCONTROLMACHINE);	//Com2 machine must send moldset
    }
    return bResult;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::SaveToCurrentMold()   						 |
|  Task     : Os讽e家舱              				                     |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
BOOL CtmControl_Mold::SaveToCurrentMold() 
{
	printf("CtmControl_Mold::SaveToCurrentMold()\n");
	BOOL    bResult = FALSE;
    g_pBlock->SetBlock(m_pContent, BLOCK_MOLDSETX_ID);  //  From Database To BlockBuffer
    memcpy(&m_Head, m_pContent,  sizeof(m_Head));
    memcpy(m_szCurrentMoldName, m_Head.acID, sizeof(m_szCurrentMoldName));
    #ifdef	D_NOWRITE_FALSH
    	tmStorageType	nStorageType = STORAGE_TYPE_FLASHEX;
    	if(GetFileType(CHECKFILETYPE))
    		nStorageType = STORAGE_TYPE_FLASH;
    	bResult = Save(m_Head, nStorageType);
    #else
    	#ifdef D_X86
    	bResult = Save(m_Head, STORAGE_TYPE_FLASH);
    	#else
    	bResult = Save(m_Head, STORAGE_TYPE_SRAM);
    	#endif
    #endif
    return bResult;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::GetMoldSetHeadAsynch() 						 |
|  Task     : 莉o家舱戈篇豪Y          				                     |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
DB_MOLDHDR* CtmControl_Mold::GetMoldSetHeadAsynch() 
{
    return  m_pHeads;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::SaveCurrentDB(DB_MOLDHDR MoldSetHead,tmStorageType StorageType)|
|  Task     : Os讽e家舱戈屁飓wCざ				                     |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
BOOL	CtmControl_Mold::SaveCurrentDB(DB_MOLDHDR MoldSetHead,tmStorageType StorageType)
{
	printf("CtmControl_Mold::SaveCurrentDB()\n");
	BOOL    bResult = FALSE;
	ComposeHyb5MoldSetData(MoldSetHead, m_pContent);
	//g_pBlock->SetBlock(m_pContent, BLOCK_MOLDSETX_ID); 			//  From Database To BlockBuffer
	//memcpy(m_pContent, &MoldSetHead, sizeof(MoldSetHead) - 4);	//	4 byte for mold unit product and media
	memcpy(&m_Head, m_pContent, sizeof(MoldSetHead));
	memcpy(&m_szCurrentMoldName, m_Head.acID, sizeof(m_szCurrentMoldName));
	//printf("SaveCurrentDB MoldSetHead=%s \n", MoldSetHead.acID);
	bResult = Save(MoldSetHead, StorageType);
	
	char*	pszTemp = NULL;
	m_nCurrentIndex = g_pDatabase->GetIndex(CURRENT_MOLD_NAME);
	pszTemp = g_pDatabase->Reads(m_nCurrentIndex);
	return bResult;
}

int	 CtmControl_Mold::ComposeHyb5MoldSetData(DB_MOLDHDR MoldSetHead, BYTE* pData)
{
	int nResult = 0;
	
	nResult = g_pBlock->SetBlock(pData, BLOCK_MOLDSETX_ID);	
	memcpy(pData, &MoldSetHead, sizeof(MoldSetHead) - 4);	//	4 byte for mold unit product and media
	return nResult;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::SaveAs(tmStorageType StorageType)             |
|  Task     : N家舱戈偏Os飓w捍Cざ				                     |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
BOOL 	CtmControl_Mold::SaveAs(tmStorageType StorageType)
{
    BOOL bResult = FALSE;
    if (m_nBlockIndex >= 0)
    {
        int nSize = 0;
        nSize = g_pBlock->GetBlockSize(m_nBlockIndex);
        if (nSize > 0)
        {
            BYTE*   pTemp = NULL;
            pTemp = new BYTE[nSize];
            g_pBlock->SetBlock(pTemp, m_nBlockIndex);
            g_tmDebugInfo->PrintDebugInfo("blockINdex =%d, m_nDataType=%d, size=%d\n", 
            							m_nBlockIndex,m_nDataType, nSize);
            bResult = CtmSarmRecordFileControl::GetInstance()->WriteRecord(m_nDataType, 1, 
                                                                           pTemp, StorageType) == nSize;
            delete []pTemp;
        }
    }

    return bResult;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::SaveAs(tmStorageType SourceStorage, tmStorageType DestStorage)|
|  Task     : N家舱戈偏Osqw捍CざOs欹t~@哟Cざ				     |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
BOOL 	CtmControl_Mold::SaveAs(tmStorageType SourceStorage, tmStorageType DestStorage)
{
    BOOL bResult = FALSE;
    if (m_nBlockIndex >= 0)
    {
        int nSize = 0;
        nSize = g_pBlock->GetBlockSize(m_nBlockIndex);
        if (nSize > 0)
        {
            BYTE*   pTemp = NULL;
            pTemp = new BYTE[nSize];
            bResult = CtmSarmRecordFileControl::GetInstance()->ReadRecord(m_nDataType, 1, 
                                                                          pTemp, SourceStorage)  == nSize;
            if (bResult)
                bResult = CtmSarmRecordFileControl::GetInstance()->WriteRecord(m_nDataType, 1, 
                                                                          pTemp, DestStorage)  == nSize;
            delete []pTemp;
        }
    }

    return bResult;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::Read(tmStorageType StorageType)               |
|  Task     : 弄wCざ杭也崭戤				                         |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
BOOL 	CtmControl_Mold::Read(tmStorageType StorageType)
{
    BOOL bResult = FALSE;
    if (m_nBlockIndex >= 0)
    {
        int nSize = 0;
        nSize = g_pBlock->GetBlockSize(m_nBlockIndex);
        if (nSize > 0)
        {
            BYTE*   pTemp = NULL;
            pTemp = new BYTE[nSize];
            bResult = CtmSarmRecordFileControl::GetInstance()->ReadRecord(m_nDataType, 1, 
                                                                          pTemp, StorageType)  == nSize;
            if (bResult) bResult = g_pBlock->GetBlock(pTemp, m_nBlockIndex) == nSize;
            delete []pTemp;
        }
    }

    return bResult;
   
}
/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::Delete(tmStorageType StorageType)             |
|  Task     : R埃wCざ杭也崭戤				                         |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
BOOL 	CtmControl_Mold::Delete(tmStorageType StorageType)
{
    BOOL bResult = FALSE;
    if (m_nBlockIndex >= 0)
    {
        bResult = CtmSarmRecordFileControl::GetInstance()->DeleteRecord(m_nDataType, StorageType) == 0;
    }
    return bResult;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::FindBlockInfoNo(int nBlockIndex)              |
|  Task     : qLBlock Index dтBlock 癸_含勖ID           				 |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
int	 	CtmControl_Mold::FindBlockInfoNo(int nBlockIndex)
{
	int nResult = -1;
	for (int i = 0; i < sizeof(m_aBlockInfo) / sizeof(m_aBlockInfo[0]); i++)
	{
		if (m_aBlockInfo[i].nBlockIndex == nBlockIndex)
		{
			nResult = i;
			break;					
		}
	}
	return nResult;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::FindBlockInfoNo(tmFileIDType FileID)          |
|  Task     : qLFileIDType挡cAdтBlock 癸莱含勖ID           			 |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
int	 	CtmControl_Mold::FindBlockInfoNo(tmFileIDType FileID)
{
	int nResult = -1;
	for (int i = 0; i < sizeof(m_aBlockInfo) / sizeof(m_aBlockInfo[0]); i++)
	{
		if (m_aBlockInfo[i].FileID == FileID)
		{
			nResult = i;
			break;					
		}
	}
	return nResult;	
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::SetBlockIndex(int nBlockIndex)                |
|  Task     : ]m讽eBlockIndex           			                     |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
void 	CtmControl_Mold::SetBlockIndex(int nBlockIndex)
{
	m_nDataType = ID_STORAGE_NOFILE;
    m_nBlockIndex = -1;
    int nIndex = FindBlockInfoNo(nBlockIndex);
    if (nIndex >= 0)
    {
    	m_nDataType = m_aBlockInfo[nIndex].FileID;
    	if( m_aBlockInfo[nIndex].nBlockIndex > 100000)
    		m_nBlockIndex = m_aBlockInfo[nIndex].nBlockIndex - 100000;
    	else
    		m_nBlockIndex = m_aBlockInfo[nIndex].nBlockIndex;
    }
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::GetSize(int nBlockIndex)                      |
|  Task     : 诰Block Index 莉oBlock氦jp                			     |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
int	 	CtmControl_Mold::GetSize(int nBlockIndex)
{
	int	nResult = 0;
	//int nIndex = FindBlockInfoNo(nBlockIndex);
	nResult = g_pBlock->GetBlockSize(m_nBlockIndex);
	return nResult;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Mold::GetSize(int nBlockIndex)                      |
|  Task     : 诰FileIDType 莉oBlock氦jp                			     |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
int	 	CtmControl_Mold::GetSize(tmFileIDType FileID)
{
	int	nResult = 0;
	int nIndex = FindBlockInfoNo(FileID);
	nResult = g_pBlock->GetBlockSize(nIndex);
	return nResult;
}


 /*! \fn int		CtmControl_Mold::CalculateSize()
 *  \brief pblock矗ㄑ氦jp,
 *  \return sxC@掸家ㄣ氦jp
 */
int		CtmControl_Mold::CalculateSize()
{
	//int	nSize = 0;
	//
	//for (int i = 0; i < (int)(sizeof(u_nBlockIDs) / sizeof(u_nBlockIDs[0])); i++)
	//{
	//	nSize += g_pBlock->GetBlockSize(u_nBlockIDs[i]);
	//}
	//printf("nSize=%d \n", nSize);
	//return 	nSize;
    return g_pBlock->GetBlockSize(BLOCK_MOLDSETX_ID);
}

int 	CtmControl_Mold::CalculateNewSize()
{
	return 0;	
}

int		CtmControl_Mold::GetMoldSize()
{
	return m_nMoldSetSize;
}

char*	CtmControl_Mold::GetMoldSetPath()
{
	return m_pszMoldSetPath;	
}

char*	CtmControl_Mold::SetMoldSetPath(char*	pszPath)
{
	if(pszPath != NULL)
	{
		memset(m_pszMoldSetPath,0,sizeof(m_pszMoldSetPath));
		strcpy(m_pszMoldSetPath, pszPath);
	}
	return m_pszMoldSetPath;	
}

//=======================================================================================
//家ㄣsx俺姝file:  ID + Value
//=======================================================================================
/*---------------------------------------------------------------------------+
|  Function : CtmControl_MoldHyb5::CtmControl_MoldHyb5(): CtmControl_Mold()  |
|  Task     : cyㄧ计				                                         |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
CtmControl_MoldHyb5::CtmControl_MoldHyb5(): CtmControl_Mold()
{
	memset(&m_MoldSetData, 0, sizeof(m_MoldSetData));
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_MoldHyb5::CtmControl_MoldHyb5():~CtmControl_Mold()  |
|  Task     : Rcㄧ计				                                         |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
CtmControl_MoldHyb5::~CtmControl_MoldHyb5()
{
	
}

BOOL CtmControl_MoldHyb5::CheckExistOldFile()
{
	char szFile[128];

	sprintf(szFile, "%s%s", MOLD_PATH, "moldset.cdb");

	int nFd = open(szFile, O_RDWR);
	//printf("CheckExistOldFile szFile=%s \n", szFile);
	if (nFd > 0)
	{
			close(nFd);
			return TRUE;
	}
	else return FALSE;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_MoldHyb5::Delete(DB_MOLDHDR MoldSetHead, tmStorageType StorageType)|
|  Task     : R埃w家ㄣ				                                     |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
BOOL	CtmControl_MoldHyb5::Delete(DB_MOLDHDR MoldSetHead, tmStorageType StorageType)
{
	char szFile[128];
  BOOL    bResult = FALSE;
  
  if (MoldSetHead.acID[0] != '\0') 
  {
      bResult = TRUE;
  }

  if (bResult) 
  {
      bResult = !(strcmp(MoldSetHead.acID, m_szCurrentMoldName) == 0);
  }
    
	int nRecord = Find(MoldSetHead, StorageType);
  if (bResult) 
  {
      if (nRecord > 0)
      {
				sprintf(szFile, "%s%s.cdb", m_pszMoldSetPath, MoldSetHead.acID);	
				remove(szFile);
      }
  }
  else 
  {
  	#ifdef	D_PXA270
  	if( StorageType != STORAGE_TYPE_USB )
  	#else
  	if( StorageType != STORAGE_TYPE_MMCARD )
  	#endif
  	{
  		SendMsg(MSG_MOLDSET_DEL_CUR, 0, StorageType, NULL);
      }
      else		//James add 秆Mぃ唰R埃MMCd江暴M豹OPW杭舀 2007/12/11 03:00Uと
      {
      	if (nRecord > 0)
       {
			    sprintf(szFile, "%s%s.cdb", m_pszMoldSetPath, MoldSetHead.acID);
			    remove(szFile);
       }	
      }
  }

   return bResult;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_MoldHyb5::Read(DB_MOLDHDR MoldSetHead, tmStorageType StorageType)|
|  Task     : 弄w家ㄣ				                                     |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
BOOL	CtmControl_MoldHyb5::Read(DB_MOLDHDR MoldSetHead, tmStorageType StorageType)
{
	BOOL	bResult = FALSE;
	char szFile[256];
	if(StorageType==STORAGE_TYPE_USB)
	{
		SetMoldSetPath(MOLD_USB_PATH);	
		
	}
	else
	{
		SetMoldSetPath(MOLD_PATH);		
	}
	
	sprintf(szFile, "%s%s.cdb", m_pszMoldSetPath, MoldSetHead.acID);
	
	//ZHBA 2013-11-8 printf("Read szFile=%s \n", szFile);
	//printf("Read szFile=%s \n", szFile);
	//printf("CtmControl_MoldHyb5::Read Name=%s m_nMoldSetSize=%d \n", MoldSetHead.acID, m_nMoldSetSize);
	int nFd = open(szFile, O_RDWR | O_CREAT );
	if (nFd >= 0)
	{
		lseek(nFd,0,SEEK_SET);
		memset(m_pContent,0,sizeof(m_pContent));
		read(nFd, m_pContent, m_nMoldSetSize);
		close(nFd);
		bResult = TRUE;
	}
	return bResult;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_MoldHyb5::Save(DB_MOLDHDR MoldSetHead, tmStorageType StorageType)|
|  Task     : Osw家ㄣ				                                     |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
BOOL	CtmControl_MoldHyb5::Save(DB_MOLDHDR MoldSetHead, tmStorageType StorageType)
{
	if(StorageType==STORAGE_TYPE_USB)
	{
		SetMoldSetPath(MOLD_USB_PATH);		
		
	}
	else
	{
		SetMoldSetPath(MOLD_PATH);	
	}
	
	int       nRecord = Find(MoldSetHead, StorageType);
	//printf("CtmControl_MoldHyb5::Save nRecord=%d \n ", nRecord);
	//printf("CtmControl_MoldHyb5::Save MoldSetHead=%s \n ", MoldSetHead.acID);
	if(nRecord > 0)
	{
		SendMsg(MSG_MOLDSET_OVERWRITE, nRecord, StorageType, NULL);
		//printf("CtmControl_MoldHyb5::Save    MSG_MOLDSET_OVERWRITE  g_bMsgBoxFlag=%d\n",g_bMsgBoxFlag);
		if(g_bMsgBoxFlag)	
		{
			char szFile[128];

			sprintf(szFile, "%s%s.cdb", m_pszMoldSetPath, MoldSetHead.acID);
			
			//printf("save szFile=%s \n", szFile);
			int nFd = open(szFile, O_RDWR | O_CREAT | O_TRUNC | O_SYNC);
			//printf("Current nFd=%d\n",nFd);
			if (nFd >= 0)
			{
				write(nFd, m_pContent, m_nMoldSetSize);

				close(nFd);
			}	
		}
	}
	else
	{
		//printf("no MsgBox...\n");
		char szFile[128];
	
		sprintf(szFile, "%s%s.cdb", m_pszMoldSetPath, MoldSetHead.acID);
		//printf("MoldSetHead.acID=%s m_nMoldSetSize=%d \n", MoldSetHead.acID, m_nMoldSetSize);
		int nFd = open(szFile, O_RDWR | O_CREAT | O_SYNC);
		//printf(" no msgbox save =%s \n", szFile);
		if (nFd >= 0)
		{
			write(nFd, m_pContent, m_nMoldSetSize);
			close(nFd);
		}	
	}
	return TRUE;
}


/*---------------------------------------------------------------------------+
|  Function : CtmControl_MoldHyb5::Save(DB_MOLDHDR MoldSetHead, tmStorageType StorageType)|
|  Task     : Osw家ㄣ				                                     |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:   			            - 	                     			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
DB_MOLDHDR*	CtmControl_MoldHyb5::GetMoldSetHead(int nStart, int Num, tmStorageType StorageType)
{
	memset(m_pHeads,0,sizeof(DB_MOLDHDR) * m_nMaxMoldSet);
	int	j = 0, i=0;
	DIR* pDir = NULL;
    struct dirent* ent = NULL;
    struct stat buf;
    map<time_t,string,greater<time_t> > files;
    int k = stat(m_pszMoldSetPath,&buf);
    
     
    if(k!=0)
    {
    	mkdir(m_pszMoldSetPath,07777);	
    }
    pDir = opendir(m_pszMoldSetPath);

   	do
    {
    	if(pDir != NULL)
    		ent = readdir(pDir);
   		if (ent == NULL) break;
    	else
    	{
    		if(strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
    			continue;
    		j++;
    		if (j >= nStart)
    		{
    			if(Num !=0)
    			{
    				char szFile[128];
    				if(strstr(ent->d_name, ".cdb") != NULL && strstr(ent->d_name, "moldset") == NULL)
    				{
	    				sprintf(szFile,"%s%s",m_pszMoldSetPath,ent->d_name);
	    				int ret = stat(szFile,&buf);
	    				if(ret<0)	continue;
	    				//files.insert(pair<time_t,string>(buf.st_ctime,string(szFile)));
	    				files.insert(pair<time_t,string>(buf.st_mtime,string(szFile)));
	    				/*wangli2016-6-12 16:13:55 files.insert ㄧ计|逼恰ApGst_ctime郐PAN|滦\WΩszFile*/
						//printf("st_mtime=%d,szFile=%s\n",buf.st_mtime,szFile);
	    				i++;
	    			}
    			}
				if(i >= Num)
					break;
			}
		}
	}while(1);
	closedir(pDir);
	map<time_t,string>::iterator file=files.begin();
	int nIndex=0;
	for(;file!=files.end(); ++file)
	{
		printf("file:%s\n",file->second.c_str());
		int nfd = open(file->second.c_str(), O_RDWR | O_CREAT);
		printf("nfd=%d\n",nfd);
		if(nfd > 0)
		{
		    read(nfd, ((DB_MOLDHDR*)(m_pHeads) + nIndex), sizeof(DB_MOLDHDR));
		    close(nfd);
			nIndex++;
		}
	}
	
	files.clear();
	return m_pHeads;
}

int CtmControl_MoldHyb5::GetMoldSetNum(tmStorageType	StorageType)
{
	//printf("CtmControl_MoldHyb5::GetMoldSetNum StorageType=%d \n", StorageType);
	int Result = 0;
	DIR* pDir = NULL;
	struct dirent* ent = NULL;
	struct stat buf;

	if( StorageType == STORAGE_TYPE_USB)
		strcpy(m_pszMoldSetPath, MOLD_USB_PATH);
	else	
		strcpy(m_pszMoldSetPath, MOLD_PATH);
	//printf("CtmControl_MoldHyb5::GetMoldSetNum  m_pszMoldSetPath=%s\n",m_pszMoldSetPath);

    int k = stat(m_pszMoldSetPath,&buf);
    if(k!=0)
    {
    	mkdir(m_pszMoldSetPath,07777);	
    }
    pDir = opendir(m_pszMoldSetPath);

    int nfd;
    int i=0;
    do
    {
    	if(pDir != NULL)
    		ent = readdir(pDir);
   		if (ent == NULL)
   			break;
    	else
    	{
    		if(strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
    			continue;
    		char szFile[128];
    		if(strstr(ent->d_name, ".cdb") != NULL && strstr(ent->d_name, "moldset") == NULL)
    		{
    			//printf("ent->d_name=%s \n", ent->d_name);
	    		sprintf(szFile,"%s%s",m_pszMoldSetPath,ent->d_name);
	    		nfd = open(szFile, O_RDWR | O_CREAT);
	    		if(nfd > 0)
	    		{
	    			read(nfd,(m_pHeads+i),sizeof(DB_MOLDHDR));
	    			close(nfd);
	    			i++;
	    		}
    			Result++;
	    	}	
    	}
    	
	}while(1);
	closedir(pDir);
	return Result;
}

int		CtmControl_MoldHyb5::Find(DB_MOLDHDR MoldSetHead, tmStorageType	StorageType)
{
     char szFile[128];
     sprintf(szFile,"%s%s.cdb",m_pszMoldSetPath,MoldSetHead.acID);
     if(access(szFile,R_OK) !=0 )
     	return 0;
     else
     	return 1;
}

int		CtmControl_MoldHyb5::CalculateNewSize()
{
	printf("\nCtmControl_MoldHyb5::CalculateNewSize()\n");
	//modify by J.Wong 2015/11/18 15:41:17
	int nSize=0, nBlockCount=0;
	long 	lDataID = 0;
	DWORD	dwDBIndex=0 ,dwTotal = 0;	
	BLOCKDATA*	pBlockData;
	DBVALUE		dbValue;
	int 		nIndex=0;
	for (int i = 0; i < (int)(sizeof(u_nBlockIDs) / sizeof(u_nBlockIDs[0])); i++)
	{
		pBlockData = g_pBlock->GetBlockData(u_nBlockIDs[i]);
		if( pBlockData != NULL )
			{
				nBlockCount = pBlockData->dwFactorTotal;
				printf("nBlockCount=%d\n",nBlockCount);
			}
		for (int j=0; j < nBlockCount; j++)
		{
			dwDBIndex = pBlockData->pwDBIndex[j];
			lDataID = g_pDatabase->IndexToDataID(dwDBIndex);
			if(lDataID >=0)
			{
				if(nIndex<MAX_MOLD_ID_COUNT)
				{
					m_lMoldID[nIndex++]=lDataID;
//					memset(&dbValue, 0, sizeof(dbValue));
//					dbValue = g_pDatabase->Read(dwDBIndex);
//					if(dbValue.DataType.wType!=TYPE_STRING)
//					{
//						nSize+=dbValue.DataType.wLength;	
//					}	
//					else
//					{
//						nSize+=1;
//						nSize+=dbValue.DataType.wLength;	
//					}
				}
			}
		}
		//dwTotal += nBlockCount;
			
	}
	for(int i = 0; i < sizeof(pszMoldset_DB)/sizeof(char*); i++)
	{
		lDataID = g_pDatabase->GetDataID(pszMoldset_DB[i]);
		if(lDataID >=0)
		{
			if(nIndex<MAX_MOLD_ID_COUNT)
			{
				m_lMoldID[nIndex++]=lDataID;
//				memset(&dbValue, 0, sizeof(dbValue));
//				dbValue = g_pDatabase->Read(pszMoldset_DB[i]);	
//				if(dbValue.DataType.wType!=TYPE_STRING)
//				{
//					nSize+=dbValue.DataType.wLength;	
//				}	
//				else
//				{
//					nSize+=1;
//					nSize+=dbValue.DataType.wLength;	
//				}
			}
			//dwTotal++;
		}	
	}
	
	m_dwMoldIDCount=nIndex;
	std::sort(m_lMoldID,m_lMoldID+m_dwMoldIDCount);
	WORD wGroupIndex=0;
	m_StartID[wGroupIndex].lStartID	=m_lMoldID[0];
	m_StartID[wGroupIndex].wCount++;
	for(int i=1; i<m_dwMoldIDCount; i++)
	{
		if(m_lMoldID[i]-m_lMoldID[i-1]==0)
		{
			//printf("m_lMoldID[%d]=%x...................\n",i,m_lMoldID[i]);	
			continue;
		}
		if((m_lMoldID[i]-m_lMoldID[i-1])==1)
		{
			m_StartID[wGroupIndex].wCount++;	
		}
		else
		{
			m_StartID[++wGroupIndex].lStartID=m_lMoldID[i];
			m_StartID[wGroupIndex].wCount++;	
		}	
	}
	m_wGroupCount=wGroupIndex+1;
	for(int i=0; i<m_wGroupCount; i++)
	{
		dwTotal+=m_StartID[i].wCount;
		long lDataID=m_StartID[i].lStartID;
		for(int j=0;j<m_StartID[i].wCount;j++)
		{
			memset(&dbValue, 0, sizeof(dbValue));
			dwDBIndex=g_pDatabase->DataIDToIndex(lDataID);
			dbValue = g_pDatabase->Read(dwDBIndex);
			nSize+=dbValue.DataType.wLength;
			lDataID++;	
		}
		//printf("m_StartID[%d]=%x,wCount=%d\n",i,m_StartID[i].lStartID,m_StartID[i].wCount);	
	}
	m_dwMoldIDCount=dwTotal;
	//printf("1:nSize=%d\n",nSize);
	//nSize +=dwTotal*(sizeof(DWORD)+sizeof(WORD));
	nSize +=(m_wGroupCount*(sizeof(DWORD)+sizeof(WORD))+m_dwMoldIDCount*sizeof(BYTE));//BYTE: ucDataType , 3 BYTES:dwID
	//printf("2:nSize=%d\n",nSize);
	nSize+=(sizeof(DB_MOLDHDR) + sizeof(DWORD)+sizeof(DWORD));//header size, total count, version
	//printf("nSize=%d\n",nSize);
	return 	nSize;
}

int		CtmControl_MoldHyb5::CalculateSize()
{
	int	nCount = 0,nSize = 0;
	
	for (int i = 0; i < (int)(sizeof(u_nBlockIDs) / sizeof(u_nBlockIDs[0])); i++)
	{
		nCount += g_pBlock->GetBlockCount(u_nBlockIDs[i]);
		//printf("nCount=%d\n",nCount);
	}
	
	//printf("2 nCount=%d \n", nCount );
	nCount += sizeof(pszMoldset_DB)/sizeof(char*);			//James add 2012/8/6 19:03:07
	
	//ZHBA 2013-11-8 printf("1 nCount=%d \n", nCount );
	nSize += nCount */* sizeof(WORD)+sizeof(DWORD)*/sizeof(HYB_VALUE);
	//printf("nCount=%d nSize=%d \n", nCount, nSize );
	nSize += sizeof(DB_MOLDHDR) + sizeof(DWORD);
	//printf("Hyb5 nSize=%d \n", nSize);
	return 	nSize;
}

int	 	CtmControl_MoldHyb5::ComposeHyb5MoldSetData(DB_MOLDHDR MoldSetHead, BYTE* pData)
{
	printf("CtmControl_MoldHyb5::ComposeHyb5MoldSetData()\n");
	int	nBlockCount = 0;
	DWORD	dwOffset = 0, dwDBIndex = 0, dwTotal = 0;
	DWORD	dwVers=MOLDSET_VERSIONS;
	long 	lDataID = 0;
	BLOCKDATA*	pBlockData;
	HYB_VALUE	HybValue;
	DBVALUE		dbValue;
	
	dwOffset = sizeof(DB_MOLDHDR) + sizeof(DWORD)+sizeof(DWORD);		//Moldset Head size
	//modify by J.Wong 2015/11/18 15:54:27
	for(int i=0;i<m_wGroupCount;++i)
	{
		//@ format .WORD wCount .DWORD dwID;
		//printf("dwOffset=%d\n",dwOffset);
		memcpy(pData+dwOffset , &m_StartID[i].wCount,sizeof(WORD));
		dwOffset+=sizeof(WORD);
		memcpy(pData+dwOffset, &m_StartID[i].lStartID,sizeof(DWORD));
		dwOffset+=sizeof(DWORD);
		long lDataID=m_StartID[i].lStartID;
		WORD wCount =m_StartID[i].wCount;
		for(int j=0; j<wCount; j++)
		{
			//printf("dwOffset=%d\n",dwOffset);
			memset(&HybValue, 0, sizeof(HybValue));
			memset(&dbValue, 0, sizeof(dbValue));
			dwDBIndex=g_pDatabase->DataIDToIndex(lDataID);
			dbValue = g_pDatabase->Read(dwDBIndex);
			
			#ifdef	D_X86
			if(dbValue.DataType.wType == TYPE_DOUBLE)
			{
				BYTE  cLen=dbValue.DataType.wLength;
				memcpy(pData+dwOffset,&cLen,sizeof(BYTE));
				dwOffset+=sizeof(BYTE);
				HybValue.dData = Pxa270DBConvert(dbValue.dData);
				memcpy(pData+dwOffset, (BYTE* )&HybValue.dData,dbValue.DataType.wLength);
				dwOffset+=dbValue.DataType.wLength;
			}	
			else 
			{
				
				
				memcpy(HybValue.acData, dbValue.acData, 8);
				if(dbValue.DataType.wType!=TYPE_STRING)
				{
					BYTE  cLen=dbValue.DataType.wLength;
					memcpy(pData+dwOffset,&cLen,sizeof(BYTE));
					dwOffset+=sizeof(BYTE);
					memcpy(pData+dwOffset, (BYTE* )&HybValue.acData,dbValue.DataType.wLength);
					dwOffset+=dbValue.DataType.wLength;
				}
				else	if(dbValue.DataType.wLength < 200 && dbValue.DataType.wLength > 0)
				{
					char* pSData = NULL;
					BYTE  cLen  = 0;
					pSData = g_pDatabase->Reads(dwDBIndex);
					cLen = dbValue.DataType.wLength;
					memcpy(pData+dwOffset, &cLen,sizeof(BYTE));
					dwOffset += sizeof(BYTE);
					if(pSData != NULL)
						memcpy(pData+dwOffset, pSData, dbValue.DataType.wLength);
					dwOffset+=cLen;
					//printf("save ====wlen=%d pSData=%s\n", wLen, pSData);
				}
			}
			#else
			memcpy(HybValue.acData, dbValue.acData, 8);
			if(dbValue.DataType.wType!=TYPE_STRING)
			{
				BYTE  cLen=dbValue.DataType.wLength;
				memcpy(pData+dwOffset,&cLen,sizeof(BYTE));
				dwOffset+=sizeof(BYTE);
				memcpy(pData+dwOffset, (BYTE* )&dbValue.acData,dbValue.DataType.wLength);
				dwOffset+=dbValue.DataType.wLength;
			}
			else 
			if(dbValue.DataType.wLength < 200 && dbValue.DataType.wLength > 0)
			{
				char* pSData = NULL;
				BYTE  cLen  = 0;
				pSData = g_pDatabase->Reads(dwDBIndex);
				cLen = dbValue.DataType.wLength;
				memcpy(pData+dwOffset, &cLen,sizeof(BYTE));
				dwOffset += sizeof(BYTE);
				if(pSData != NULL)
					memcpy(pData+dwOffset, pSData, dbValue.DataType.wLength);
				dwOffset+=cLen;
				//printf("save ====wlen=%d pSData=%s\n", wLen, pSData);
			}
			#endif
			//printf("lDataID=%x,dwOffset=%d,dbValue.DataType.wLength=%d\n",lDataID,dwOffset,dbValue.DataType.wLength);
			lDataID++;		
		}
			
	}
	//ZHBA 2013-11-8 
	memcpy(pData, &MoldSetHead, sizeof(MoldSetHead));
	memcpy(pData+sizeof(DB_MOLDHDR),&dwVers,sizeof(dwVers));
	printf("Compose::dwVers=%x\n",dwVers);
	printf("Compose::m_dwMoldIDCount=%d\n",m_dwMoldIDCount);
	memcpy(pData+sizeof(DB_MOLDHDR)+sizeof(DWORD), &m_dwMoldIDCount, sizeof(m_dwMoldIDCount));
	printf("dwOffset=%ld, m_dwMoldIDCount=%ld,memtotal=%ld\n",dwOffset, m_dwMoldIDCount,*(DWORD*)(pData+(sizeof(DB_MOLDHDR)+sizeof(DWORD))));
	return dwOffset;	
}

BOOL 	CtmControl_MoldHyb5::SaveToCurrentMold(DB_MOLDHDR MoldSetHead, tmStorageType StorageType ) 
{
		printf("CtmControl_MoldHyb5::SaveToCurrentMold()\n");
	BOOL	bResult = FALSE;
    int		i = 0, nTotal = 0;
    DWORD	dwOffset = 0;
    DWORD	dwVers=0;
    BYTE	ucDataType=0;
    HYB_VALUE	dbHybValue;
    DBVALUE		dbValue;
    DB_MOLDHDR 	dbMoldSetHead;
	DWORD	dwHeatType;
    
	dwHeatType = GetDBValue("M3_CONF_TEMPERCARD_HEATE_TYPE1").lValue & 0x00FFFFFF;/*wangli2016-9-13 16:11:12 Os┏24臁A品钮[荐摸A诀竟把计*/

    if(g_pExTable->GetTableValue(0,"D_SVRT"))
    {
    	for (int i=0; g_apszParallID[i]!=NULL; i++)/*zhongjw 2015-12-24 キ娅缀时爆勖霭鸭啤Aぃ弄家ㄣ杭vT*/
			{
				nParallValue[i] = GetDBValue(g_apszParallID[i]).lValue; 			
			}
		}

    bResult = Read(MoldSetHead, StorageType);
    //printf("bResult=%d \n", bResult);
    if(bResult)
    {
	    memset(&dbMoldSetHead, 0, sizeof(dbMoldSetHead));
	    memcpy(&dbMoldSetHead, m_pContent, sizeof(DB_MOLDHDR));
	    //printf("Header Size=%d\n",sizeof(DB_MOLDHDR));
	    dwOffset += sizeof(DB_MOLDHDR); 
	    //printf("dbMoldSetHead=%s\n",dbMoldSetHead.acID);
	    memcpy(&dwVers, m_pContent + dwOffset, sizeof(DWORD));
	    //printf("dwVers=%d\n",dwVers);
    	if(dwVers!=MOLDSET_VERSIONS)
    	{	
    			SendMsg(MSG_NB_HMI_SEND_MOLDVERSERR, 0, 0, NULL);
    			return FALSE;
    	}
    	dwOffset+=sizeof(DWORD);
    	
	    g_pBlock->GetBlock((BYTE*)&dbMoldSetHead,BLOCK_MOLDHDR_ID,TRUE);
		//memcpy(&nTotal, m_pContent + dwOffset, sizeof(DWORD));
		nTotal = *(DWORD*)(m_pContent + dwOffset);
		printf("CtmControl_MoldHyb5::SaveToCurrentMold111 SaveToCurrentMold nTotal=%d \n", nTotal);
		dwOffset += sizeof(DWORD);
		if(nTotal > 20000)
			return FALSE;
//		printf("CtmControl_MoldHyb5::SaveToCurrentMold222 SaveToCurrentMold nTotal=%d \n", nTotal);
//		for(i = 0; i < nTotal; i++)
//		{
//			WORD wSize=0;
//			memset(&dbHybValue, 0, sizeof(dbHybValue));
//			memcpy(&dbHybValue, m_pContent+dwOffset, sizeof(DWORD));
//			wSize=sizeof(DWORD);
//			dwOffset += wSize;
//			dbValue = g_pDatabase->Read(g_pDatabase->DataIDToIndex(dbHybValue.dwID));
//			//memcpy(&dbHybValue.ucDataType,m_pContent+dwOffset,sizeof(BYTE));
//			//ucDataType=dbHybValue.ucDataType;
//			//wSize =sizeof(WORD);
//			//dwOffset += wSize;
//
//			//if(dbHybValue.ucState == DB_SUCCESS)
////			{
//			//printf("dbHybValue.dwID=%d \n", dbHybValue.dwID);
//				//dbValue = g_pDatabase->Read(g_pDatabase->DataIDToIndex(dbHybValue.dwFeature&0xFFFFFF));
//				//memcpy(&dbValue, &(g_pDatabase->Read(g_pDatabase->DataIDToIndex(dbHybValue.dwID))), sizeof(dbValue));
//				printf("i=%d,ucDataType=%d,wType=%d,ID=%x\n",i,dbHybValue.ucDataType,dbValue.DataType.wType,dbHybValue.dwID);
//				//if(dbValue.DataType.wType ==(dbHybValue.ucDataType))
//				{
//					#ifdef	D_X86
//						 if(dbValue.DataType.wType != TYPE_STRING)
//						{
//						
//							memcpy(dbHybValue.acData,m_pContent+dwOffset,dbValue.DataType.wLength);
//							memcpy(dbValue.acData, dbHybValue.acData, dbValue.DataType.wLength);
//							dwOffset+=dbValue.DataType.wLength;
//						}
//						else
//						{
//							if(dbValue.DataType.wLength < 200 && dbValue.DataType.wLength > 0)
//							{
//								char szData[256];
//								BYTE  cLen  = 0;
//								int	  nIndex= 0;
//								
//								memcpy(&cLen, m_pContent+dwOffset, sizeof(BYTE));
//								dwOffset += sizeof(BYTE);
//								if(cLen > 0 && cLen < 200)
//								{
//									if(cLen > dbValue.DataType.wLength)
//										cLen = dbValue.DataType.wLength;
//									memset(szData, 0, sizeof(szData));
//									memcpy(szData, m_pContent+dwOffset, cLen);
//									//nIndex = g_pDatabase->DataIDToIndex(dbHybValue.dwFeature&0xFFFFFF);
//									
//								} 
//								dwOffset+=cLen;
//							}
//						}
//					#else
//						if (dbValue.DataType.wType != TYPE_STRING)
//						{
//							memcpy(dbHybValue.acData,m_pContent+dwOffset,dbValue.DataType.wLength);
//							memcpy(dbValue.acData, dbHybValue.acData, dbValue.DataType.wLength);
//							dwOffset+=dbValue.DataType.wLength;
//							printf("CtmControl_MoldHyb5::SaveToCurrentMold  i=%d, dbValue.lID=%d\n", i, dbValue.lID);
//						}
//						else
//						{
//							printf("CtmControl_MoldHyb5::SaveToCurrentMold  i=%d, nameid=%s \n", i, g_pDatabase->GetString(g_pDatabase->DataIDToIndex(dbHybValue.dwID)));
//							if(dbValue.DataType.wLength < 200 && dbValue.DataType.wLength > 0)
//							{
//								char szData[256];
//								BYTE  cLen  = 0;
//								int	  nIndex= 0;
//								
//								memcpy(&cLen, m_pContent+dwOffset, sizeof(BYTE));
//								dwOffset += sizeof(BYTE);
//								if(cLen > 0 && cLen < 200)
//								{
//									if(cLen > dbValue.DataType.wLength)
//										cLen = dbValue.DataType.wLength;
//									memset(szData, 0, sizeof(szData));
//									memcpy(szData, m_pContent+dwOffset, cLen);
//									nIndex = g_pDatabase->DataIDToIndex(dbHybValue.dwID);
//									g_pDatabase->Writes(szData,nIndex, cLen);
//									
//								} 
//								//memcpy(dbHybValue.acData,m_pContent+dwOffset,8);
//								//memcpy(dbValue.acData, dbHybValue.acData, 8);
//								dwOffset+=cLen;
//								//printf("read ====wlen=%d szData=%s \n", wLen, szData);
//							}
//						}
//							//strncpy(dbValue.pcData, dbHybValue.acData, dbValue.DataType.wLength);
//					#endif
//					if(dbValue.DataType.wType != TYPE_STRING)
//						g_pDatabase->Write(&dbValue, TRUE);
//				}		
//		}
//@	modify by J.Wong 2015/11/18 17:55:29
		int nAddCount=0;
		do{
			printf("dwOffset=%d\n",dwOffset);
			WORD wCount;
			memcpy(&wCount,m_pContent+dwOffset,sizeof(WORD));
			nAddCount+=wCount;
			dwOffset+=sizeof(WORD);
			long lDataID;
			memcpy(&lDataID,m_pContent+dwOffset,sizeof(DWORD));
			printf("wCount=%d,lDataID=%x,nTotal=%d\n",wCount,lDataID,nTotal);
			dwOffset+=sizeof(DWORD);
			for(int i=0; i<wCount; ++i)
			{
				memset(&dbHybValue, 0, sizeof(dbHybValue));
				int nIndex=g_pDatabase->DataIDToIndex(lDataID);
				BYTE cLen=0;
				memcpy(&cLen,m_pContent+dwOffset,sizeof(BYTE));
				dwOffset+=sizeof(BYTE);
				if(nIndex<0)	
				{
					dwOffset+=cLen;	
				}
				dbValue = g_pDatabase->Read(nIndex);
				//printf("lDataID=%x,cLen=%d,wLength=%d\n",lDataID,cLen,dbValue.DataType.wLength);
				#ifdef	D_X86
				if(dbValue.DataType.wType != TYPE_STRING)
				{
					if(cLen==dbValue.DataType.wLength)
					{		
						memcpy(dbHybValue.acData,m_pContent+dwOffset,dbValue.DataType.wLength);
						memcpy(dbValue.acData, dbHybValue.acData, dbValue.DataType.wLength);
						dwOffset+=dbValue.DataType.wLength;
					}
					else
					{
						dwOffset+=cLen;		
					}
					
				}
				else
				{
					if(dbValue.DataType.wLength < 200 && dbValue.DataType.wLength > 0)
					{
						char szData[256];
						int	  nIndex= 0;		
						if(cLen > 0 && cLen < 200)
						{
							if(cLen > dbValue.DataType.wLength)
							cLen = dbValue.DataType.wLength;
							memset(szData, 0, sizeof(szData));
							memcpy(szData, m_pContent+dwOffset, cLen);
						} 
						dwOffset+=cLen;
					}
				}
				#else
				if (dbValue.DataType.wType != TYPE_STRING)
				{
					if(cLen==dbValue.DataType.wLength)
					{		
						memcpy(dbHybValue.acData,m_pContent+dwOffset,dbValue.DataType.wLength);
						memcpy(dbValue.acData, dbHybValue.acData, dbValue.DataType.wLength);
						dwOffset+=dbValue.DataType.wLength;
					}
					else
					{
						dwOffset+=cLen;		
					}
				}
				else
				{
					//printf("CtmControl_MoldHyb5::SaveToCurrentMold  i=%d, nameid=%s \n", i, g_pDatabase->GetString(g_pDatabase->DataIDToIndex(dbHybValue.dwID)));
					if(dbValue.DataType.wLength < 200 && dbValue.DataType.wLength > 0)
					{
						char szData[256];
						int	  nIndex= 0;
						if(cLen > 0 && cLen < 200)
						{
							if(cLen > dbValue.DataType.wLength)
								cLen = dbValue.DataType.wLength;
							memset(szData, 0, sizeof(szData));
							memcpy(szData, m_pContent+dwOffset, cLen);
							nIndex = g_pDatabase->DataIDToIndex(dbHybValue.dwID);
							g_pDatabase->Writes(szData,nIndex, cLen);
									
						} 
						dwOffset+=cLen;
						//printf("read ====wlen=%d szData=%s \n", wLen, szData);
					}
				}
				#endif
				if(dbValue.DataType.wType != TYPE_STRING)
				g_pDatabase->Write(&dbValue, TRUE);
				lDataID++;
			}
			
		}while(nAddCount<nTotal);
		
		int nDataIndex = 0;
		nDataIndex = g_pDatabase->GetIndex("MHDR_MODULE_NULL_NULL_MODULENAME");
		g_pDatabase->Writes(dbMoldSetHead.acID, nDataIndex, sizeof(dbMoldSetHead.acID));
		nDataIndex = g_pDatabase->GetIndex("MHDR_MODULE_NULL_NULL_MODULEMATERIAL");
		g_pDatabase->Writes(dbMoldSetHead.szMaterial, nDataIndex, sizeof(dbMoldSetHead.szMaterial));
		nDataIndex = g_pDatabase->GetIndex("MHDR_MODULE_NULL_NULL_MODULECOLOR");
		g_pDatabase->Writes(dbMoldSetHead.szColor, nDataIndex, sizeof(dbMoldSetHead.szColor));
		
		/*JOYCE2015-11-12  kernelw拽,放爪苯uぃsSRAM,放抓d把计iHsxF*/ 
//		for(int i = 0; i < sizeof(pszMoldset_TempCard_DB)/sizeof(char*); i++) /*JOYCE20150513 家ㄣsxuて,s家ㄣ傻L惠O放抓d戈,b弄瑟奖掸DSP放moldset3涵圈PBe倒放抓d戈僻Yi;o妓i搭ぶsx家ㄣゅンjp*/
//		{
//			//printf("         pszMoldset_Temp55_DB[%d]=%d\n", i, GetDBValue(pszMoldset_Temp55_DB[i]).lValue);
//			long lTemp = GetDBValue(pszMoldset_Temp55_DB[i]).lValue;
//			SetDBValue(pszMoldset_TempCard_DB[i], lTemp, FALSE);
//			//printf("pszMoldset_TempCard_DB[%d]=%d\n", i, GetDBValue(pszMoldset_TempCard_DB[i]).lValue);
//		}
		
        if(g_pExTable->GetTableValue(0,"D_SVRT"))
      	{
      		ReadWarningCnt();/*zhongjw 2015-12-23 家ㄣ弄ЧΘZAs弄玛家溃O菏代O牡厨Ω计涵*/
      		for (int i=0; g_apszParallID[i]!=NULL; i++)
					{
						SetDBValue(g_apszParallID[i],nParallValue[i], FALSE); 			
					}
      	}

		dwHeatType = dwHeatType | (GetDBValue("M3_CONF_TEMPERCARD_HEATE_TYPE1").lValue & 0xFF000000);
		SetDBValue("M3_CONF_TEMPERCARD_HEATE_TYPE1", dwHeatType ,FALSE); /*wangli2016-9-13 16:14:00 齑_C24 诀竟把计Aぃ弄家ㄣ把计vT*/


		if(g_ptaskdsp != NULL)
		{
			g_ptaskdsp->WriteValue(COMM_SENDCONTROLMOLDSET);
			g_ptaskdsp->WriteValue(COMM_ETH_SENDCONTROLNEWMOLDSET2);
			g_ptaskdsp->WriteValue(COMM_ETH_SENDCONTROLNEWMOLDSET3);
			if (CtmConfig::GetInstance()->GetMachineType() & MACHINE_TYPE_OIL_DC)
				g_ptaskdsp->WriteValue(COMM_SENDCONTROLMOLDSETB);
		}		
        if(g_ptaskCom2dsp != NULL)
			g_ptaskCom2dsp->WriteValue(COMM_SENDCONTROLMOLDSET);	//Com2 machine must send moldset	
		if(g_ptaskdsp28_M3 != NULL)
		{
			int nNum = sizeof(pszMoldset_DB)/sizeof(pszMoldset_DB[0]); /*kernelw拽,放爪苯uぃsSRAM,放抓d把计iHsxF*/  //pszMoldset_TempCard_DB
			g_ptaskdsp28_M3->WriteValue(9, nNum, pszMoldset_DB);
			//printf("sync \n");
		}
	}
    return TRUE;
}

BOOL CtmControl_MoldHyb5::SaveToCurrentMold() 
{
	BOOL    bResult = FALSE;
    g_pBlock->SetBlock(m_pContent, BLOCK_MOLDSETX_ID);  //  From Database To BlockBuffer
    memcpy(&m_Head, m_pContent,  sizeof(m_Head));
    memcpy(m_szCurrentMoldName, m_Head.acID, sizeof(m_szCurrentMoldName));
    memset(m_pContent,0,sizeof(m_pContent));
    ComposeHyb5MoldSetData(m_Head, m_pContent);
     
    //printf("m_szCurrentMoldName=%s\n",m_szCurrentMoldName);
    #ifdef	D_NOWRITE_FALSH
    	tmStorageType	nStorageType = STORAGE_TYPE_FLASHEX;
    	if(GetFileType(CHECKFILETYPE))
    		nStorageType = STORAGE_TYPE_FLASH;
    	bResult = Save(m_Head, nStorageType);
    #else
    	#ifdef D_X86
    	bResult = Save(m_Head, STORAGE_TYPE_FLASH);
    	#else
    	bResult = Save(m_Head, STORAGE_TYPE_SRAM);
    	#endif
    #endif
    return bResult;
}

void	CtmControl_MoldHyb5::ReadWarningCnt()/*zhongjw 2015-12-23 家ㄣ弄ЧΘZAs弄玛家溃O菏代O牡厨Ω计涵*/
{
	WORD 	wWarningCntData = 0;
 	char	szPath[256];
	char	m_szCopyFile[256];
  char	pszDB[256];

	char*   pDataID = "MSET_SCRW_HLDP_NULL_W068E";  
	memset(pszDB, 0, sizeof(pszDB));
	memset(szPath, 0, sizeof(szPath));
	memset(m_szCopyFile, 0, sizeof(m_szCopyFile));
	sprintf(szPath, "%s", "/conf/WarningCntData");
	sprintf(m_szCopyFile, "%s/WarningCntData.cdb", szPath);
	int nFd =  open(m_szCopyFile, O_RDWR);

	if (nFd >= 0)
	{
		read(nFd, &wWarningCntData, sizeof(wWarningCntData));
		SetDBValue(pDataID, wWarningCntData,FALSE);
	}
	else
		SetDBValue(pDataID, 0,FALSE);
 	close(nFd);
 	
}

#ifndef	D_BEOBJECT_CTMCONTROL_MOLD
CObject*	CreateInstance(char* Name)
{
	//printf("CreateInstance Name=%s \n", Name);
	CObject*	pResult = Create(Name);
	if (pResult != NULL)
	{
		(static_cast<CtmPackClass*>(pResult))->CreateSelf();
	}
	return pResult;
}

void	ReleaseInstance(CObject* pInstance)
{
	if (pInstance != NULL)
		(static_cast<CtmPackClass*>(pInstance))->FreeSelf();
	delete pInstance;
	pInstance = NULL;
}

#endif
