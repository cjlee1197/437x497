/*===========================================================================+
|  Class    : CtmControl_Error	                                             |
|  Task     : Alarm Server Function	    	                     			 |
|----------------------------------------------------------------------------|
|  Compile  : G++(GCC)3.2                                                    |
|  Link     : G++(GCC)3.2                                                    |
|  Call     :                                                                |
|----------------------------------------------------------------------------|
|  Author   : James		                                                     |
|  Version  : V1.00                                                          |
|  Creation : 05/11/2008	                                                 |
|  Revision : 05/11/2008  				                                     |
+===========================================================================*/
#include	"tmControl_Error.h"
#include	"../../utils.h"
#include	"../../tmdebug.h"
#include	"../../tmconfig.h"
#include	"../../iotable.h"//Andy 20081028
#include	"../libiNetComm.h"
#include	"../dsp54/tmTableG.h"
#include	"../../tmshmsg.h"
#include 	"../../tmnbmsg.h"
#include 	"../../commonaction.h" //JOYCE2011-4-11 add
#include	"../../filerecord.h"
#include "../../taskammeter.h"
//#include "../picker_comm/tmHmi485cmd.h"
//#include "../picker_comm/tmHmi485cmd.cpp"

IMPLEMENT_DYNCREATE(CtmControl_Error, CtmControl)

#define		ERRORLOOPTIMER 	300
#define		DRIVE_NUM		2
#define 	ERRORSTRMAX_NUM	10
#define		ERROR_STR_LEN	1024

#define 	RbtMaxErrorCnt   7    //bit0~bit6
//SYS_STAT_FOR_485  sysStat; 

/*===========================================================================+
|           Constants                                                        |
+===========================================================================*/
int		CtmControl_Error::m_nErrorCount = 0;
char*	CtmControl_Error::m_pszError[64] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL,
											NULL, NULL, NULL, NULL, NULL, NULL, NULL};
tmDB_ERROR		CtmControl_Error::m_MsgCurrent;
tmDB_ERROR		CtmControl_Error::m_MsgIndex;

BOOL	b_AlarmState = TRUE;
BOOL	b_PromptBar  = FALSE; ///Andy 20100723
BOOL	b_Error2 = FALSE;
WORD 	wErrorID =0xFFFF;

//JOYCE2011-4-11 add
BOOL	b_AddTimer = FALSE;
WORD	u_wErrorIndex = 0;
long	l_lLoopTimer = ERRORLOOPTIMER;
char 	u_szErrorStr[ERROR_STR_LEN];
BOOL	u_bErrorChangeFlag = FALSE;
unsigned long 	u_Unicode[1024];

WORD	wOldErrorStrIndex[8] = {0,0,0,0,0,0,0,0};
WORD	wMoldTempErrStrIndex = 0, wTempErrStrIndex = 0;
WORD	wMoldTempFlag = 0, wTempFlag = 0;
int		nMuCellErrorState = 0;
int		u_iAlarmNum = 0;/*JOYCE2015-2-2*/
/*===========================================================================+
|           Type	                                                         |
+===========================================================================*/

/*===========================================================================+
|           Global variable                                                  |
+===========================================================================*/

/*===========================================================================+
|           Function implementation                                          |
+===========================================================================*/	
/*---------------------------------------------------------------------------+
|  Function : CtmControl_Error::CtmControl_Error()				             |
|  Task     :  CtmControl_Errorr構造函數                                      |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:                           -                                    |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
CtmControl_Error::CtmControl_Error(): CtmControl()
{
	m_ErrorListHead = (tmErrorInfo*)malloc(sizeof(tmErrorInfo)); //JOYCE2011-4-11 
	m_ErrorListHead->pNext = NULL;                               //JOYCE2011-4-11 
	
	m_iRealIndex = 0xFFFFFFFF;	
}
/*---------------------------------------------------------------------------+
|  Function : CtmControl_Error::~CtmControl_Error()				             |
|  Task     :  CtmControl_Error析構函數                                      |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:                           -                                    |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
CtmControl_Error::~CtmControl_Error()
{
		
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Error::CreateSelf()				             	 |
|  Task     :  Initialize Error Service                                      |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:                           -                                    |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
int		CtmControl_Error::CreateSelf()
{
	//InitControl();
	return 0;	
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Error::FreeSelf()				             	     |
|  Task     :  Relase Error Service                                          |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:                           -                                    |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
int		CtmControl_Error::FreeSelf()
{
	return 0;	
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Error::AddErrorLog(DWORD wID)               	     |
|  Task     : Add  Error log        					     	             |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:                           -                                    |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
BOOL   CtmControl_Error::Robot_AddErrorLog(WORD wID , WORD wGroup)
{
	pthread_mutex_lock(&m_MutexErrMsg);
	int	nIndex = 0;
	
	printf("AddErrorLog: %d %d \n",wID,wGroup);
	m_MsgCurrent.OilError.dwID = wID;    
	m_MsgCurrent.OilError.dwShotCount = (DWORD)wGroup;
	GetDate(&m_MsgCurrent.OilError.dateStart);
	GetTime(&m_MsgCurrent.OilError.timeStart);
	m_MsgCurrent.OilError.dateFixed.year = 0;
	m_MsgCurrent.wSource		= tmOIL_ERRORFLAG;
	
	if (m_MsgIndex.wCount < CtmConfig::GetInstance()->GetErrorMaxNum()) 
		m_MsgIndex.wCount++;
	
	nIndex = m_MsgIndex.wIndex + 1;
	CtmSarmRecordFileControl::GetInstance()->WriteRecord(ID_ERROR_SRAMFILE, nIndex, &m_MsgCurrent);
	
	if ((++m_MsgIndex.wIndex) >= (CtmConfig::GetInstance()->GetErrorMaxNum())) 
		m_MsgIndex.wIndex = 0; 		
	CtmSarmRecordFileControl::GetInstance()->WriteRecord(ID_ERROR_SRAMFILE, 0, &m_MsgIndex);
	    
  
	//SendMsg(MSG_USER_SH_ERROR_ADD, nIndex, m_iRealIndex, NULL);
	
	pthread_mutex_unlock(&m_MutexErrMsg);
	
	return TRUE;
}
		
BOOL   CtmControl_Error::AddErrorLog(DWORD dwID, WORD	wSource)
{
	printf("AddErrorLog = %d wSource=%d\n",dwID,wSource);
	//if(GetDBValue("CONF_CODE_WRITE_NULL_W0BB0").lValue == 1)  /*@25E-1 boot程序, return*/
	//return TRUE;

	pthread_mutex_lock(&m_MutexErrMsg);
	int	nIndex = 0;
	m_MsgCurrent.OilError.dwID = dwID;
	    
	m_MsgCurrent.OilError.dwShotCount = GetDBValue("PROD_PRODUCT_PRODUCT_NULL_REALSHOTCOUNT").lValue+1;
	GetDate(&m_MsgCurrent.OilError.dateStart);
	GetTime(&m_MsgCurrent.OilError.timeStart);
	m_MsgCurrent.OilError.dateFixed.year = 0;
	m_MsgCurrent.wSource		= wSource;//JOYCE2011-4-11  tmOIL_ERRORFLAG;
	
	if (m_MsgIndex.wCount < CtmConfig::GetInstance()->GetErrorMaxNum()) 
		m_MsgIndex.wCount++;
	printf("m_MsgIndex.wCount = %d\n",m_MsgIndex.wCount);
	nIndex = m_MsgIndex.wIndex + 1;
	if(CtmConfig::GetInstance()->GetRecordType() == 1)
	{
		printf("CManageFile\n");
		CManageFile::GetInstance()->WriteRecord(FILE_RECORD_ALARM, nIndex, &m_MsgCurrent, sizeof(m_MsgCurrent));
	}
	else
	{
		printf("CtmSarmRecordFileControl\n");
		CtmSarmRecordFileControl::GetInstance()->WriteRecord(ID_ERROR_SRAMFILE, nIndex, &m_MsgCurrent);
	}
	
	if ((++m_MsgIndex.wIndex) >= (CtmConfig::GetInstance()->GetErrorMaxNum())) 
		m_MsgIndex.wIndex = 0; 	
			
	if(CtmConfig::GetInstance()->GetRecordType() == 1)
	{
		tmFileRecordHeadInfo	HeadInfo;
		HeadInfo.nCount = m_MsgIndex.wCount;
		HeadInfo.nIndex = m_MsgIndex.wIndex;
		CManageFile::GetInstance()->WriteRecord(FILE_RECORD_ALARM, 0, &HeadInfo, sizeof(HeadInfo));
	}
	else
		CtmSarmRecordFileControl::GetInstance()->WriteRecord(ID_ERROR_SRAMFILE, 0, &m_MsgIndex);
	    

	g_pMainFrame->GetPromptBar()->ShowAlarm(TRUE);/*JOYCE2011-12-31 COM1&COM2都通訊時,警報紅條出現/消除比字串慢的問題*/
	SendMsg(MSG_USER_SH_ERROR_ADD, nIndex, m_iRealIndex, NULL);
	ChangeErrorList(dwID, wSource, 0, 1); //JOYCE2011-4-11 
	pthread_mutex_unlock(&m_MutexErrMsg);
	u_iAlarmNum++;/*JOYCE2015-2-2*/
	
	return TRUE;
}

/*---------------------------------------------------------------------------+
|  Function : BOOL    CtmControl_Error::ClearErrorLog()               	     |
|  Task     : Clear Error log        					     	             |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:                           -                                    |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
BOOL    CtmControl_Error::ClearErrorLog()
{
	pthread_mutex_lock(&m_MutexErrMsg);
	if (g_pMainFrame->GetPromptBar()->GetErrorCount() <= 0)
	{
		m_MsgIndex.wIndex =
		m_MsgIndex.wCount = 0;   
		if(CtmConfig::GetInstance()->GetRecordType() == 1)
			CManageFile::GetInstance()->WriteRecord(FILE_RECORD_ALARM, 0, &m_MsgIndex, sizeof(m_MsgIndex));
		else
			CtmSarmRecordFileControl::GetInstance()->WriteRecord(ID_ERROR_SRAMFILE,0, &m_MsgIndex);
	}
	else
	{
		MsgBox(g_MultiLanguage["VM_ALARM_NOFIX"], tmFT_CODE_TECH);
	}
	pthread_mutex_unlock(&m_MutexErrMsg);
	
	return TRUE;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Error::Destroy_ErrorLog()               	     	 |
|  Task     : Destory Control   						     	             |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:                           -                                    |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
void	CtmControl_Error::Destroy_ErrorLog()
{
	pthread_mutex_destroy(&m_MutexErrMsg);
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Error::Error_Control()               	     		 |
|  Task     : Error Control   						     	                 |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:                           -                                    |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
void   	CtmControl_Error::Error_Control()
{
		Error_Control_New();		
}

void	CtmControl_Error::Error_Control_Card()
{
	DWORD	dwID	 = 0, dwIndex = 0, dwErrorStrIndex = 0;
	static	DWORD dwOldErrorID[8] = {0};
	DWORD	dwNewErrorID = 0;
	char*	pszErrorID[] = 
	{
		"MOLD_INTERFACE_ERROR1",
		"STATE_ALARM2_ON_INJECT_28ERRORDATA",//"MOLD_INTERFACE_ERROR1",               /*JOYCE2014-10-21 原先面板向28申請警報，改由28傳給55，再由55傳給HMI*/
		"STATE_ALARM2_ON_CHARGE_28ERRORDATA",//"EJECT_INTERFACE_ERROR1",
		"STATE_ALARM2_ON_CLAMP_28ERRORDATA",//"INJECT_DWAXIS1_INTERFACE_ERROR1",
		"STATE_ALARM2_ON_EJECT_28ERRORDATA",//"CHARGE_DWAXIS1_INTERFACE_ERROR1",
		"STATE_ALARM2_ON_NOZZLE_28ERRORDATA",	
	};
	for(int i = 0; i < sizeof(pszErrorID)/sizeof(char*); i++)
	{
		dwNewErrorID = GetDBValue(pszErrorID[i]).lValue;
		if(dwNewErrorID != dwOldErrorID[i])
		{
			//printf("Error_Control_Card dwNewErrorID=%x dwOldErrorID[%d]=%x\n", dwNewErrorID, i, dwOldErrorID[i]);
			if((dwNewErrorID & 0xFFFF) == 0)
			{
				dwErrorStrIndex =  dwOldErrorID[i];
    			FixErrorLog((DWORD)dwErrorStrIndex, tmM3_ERRORFLAG);
			}
			else
			{
				//Prompt(g_MultiLanguage[wErrorStrIndex],1);
				if(dwOldErrorID[i] != 0)
					FixErrorLog((DWORD)dwOldErrorID[i], tmM3_ERRORFLAG);
				dwOldErrorID[i] = dwNewErrorID;
				dwErrorStrIndex = dwNewErrorID;
				AddErrorLog((DWORD)dwErrorStrIndex, tmM3_ERRORFLAG);
			}
		}
		dwOldErrorID[i] = dwNewErrorID;
	}
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Error::Error_Control_New()           	     		 |
|  Task     : Error Control   						     	                 |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:                           -                                    |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
void   	CtmControl_Error::Error_Control_New() //JOYCE2011-4-11 
{
	short		i;
	WORD		cIndex = tmERROR_NULL, RealIndex;
	WORD		wErrorFlag;	//wCoreErrorFlag;
	WORD		wErrorStrIndex = g_MultiLanguage.GetStrKeyIndex("MSG_DUMMY"); //JOYCE2008-11-7 給初始值
	DWORD		dwID, dwIndex, dwValue;
	BOOL		bSPdoor=FALSE,bSPbackdoor=FALSE,bSPcoreLoc=FALSE,bSPcorePos=FALSE,bSProbot=FALSE;
	int			iResult = 0;

	int			ERR_BEGIN				= g_MultiLanguage.GetStrKeyIndex("ERR_0F_TEMPERR");
	int			ERR_0E_PLSCLSDOOR		= g_MultiLanguage.GetStrKeyIndex("ERR_0E_PLSCLSDOOR");
	int			ERR_0D_PLSOPNDOOR		= g_MultiLanguage.GetStrKeyIndex("ERR_0D_PLSOPNDOOR");

	dwID = g_pDatabase->GetDataID("STATE_ALARM_ON_STEP1_ERRORDATA");
	//James add HTK530 ---28警報字串顯示
	long long lDsp28ErrorID = GetDBValue("SYS_HMI_NULL_NULL_RESERVED40").lValue;
	int		  DSP28ERR_BEGIN	= g_MultiLanguage.GetStrKeyIndex("ERR_0F_TEMPERR2");
	if(lDsp28ErrorID > 0)
	{
		printf("lDsp28ErrorID > 0\n");
		Prompt(g_MultiLanguage[DSP28ERR_BEGIN+lDsp28ErrorID],1); //標準之錯誤字串顯示
	}
	/*
	WORD	wDSPLIBDaysCode=GetDBValue("CONF_CODE_WRITE_NULL_DATA16").lValue;
	WORD	wDSPLIBYearCode=GetDBValue("CONF_CODE_WRITE_NULL_MCHINEDATA1").lValue;
	
	for (i=tmMAX_OP_ERRORSAVE+1; i>=0; i--) //改為掃描16個WORD
    {
			if((wDSPLIBDaysCode>=0x1831)&&(wDSPLIBYearCode==0x2011)||(wDSPLIBYearCode>=0x2012)) 
				{
    		if(i == 12) continue;//第13個WORD要跳過去,error2的E40取代STAT.ERROR+12 //JOYCE2011-10-12
    		}

    	if(i == 14) continue;//第15個WORD要跳過去 //Andy 20090210
    	dwIndex = g_pDatabase->DataIDToIndex(dwID+i);

			if((i == 15) && (GetDBValue(dwIndex).lValue & 0x8000)) continue;//JOYCE2013-10-11 ERROR+15的BIT15要跳過去,DSP把它作為 驅動器溫度狀態的warning flag

    	if (wErrorFlag = GetDBValue(dwIndex).lValue)
        {
        	cIndex  = (char)i*16 + (char)_ScanBitR(wErrorFlag);  // Scan the 1's bit from left to right (Reverse)
        	iResult = (int)cIndex;		//用iResult傳遞Assign!!
        	m_iRealIndex = iResult;
        	wErrorStrIndex = g_pExTable->GetTableValue(CNT_TABLE_ERROR,(int*)&iResult,&dbeflg); //再用iResult得到反饋結果(優先級)
        	//printf("result: %d,RealIndex: %d\n",iResult,RealIndex);
        	//優先級最低，則需要繼續掃描後面在WORD或BIT！
        	if(iResult == 0)	
        		{
       				WORD wIndex1,wIndex2;
       				//一個從左邊掃描，一個從右邊掃描！！
       				wIndex1 = _ScanBitF(wErrorFlag);
       				wIndex2 = _ScanBitR(wErrorFlag);
       				//如果相等代表此WORD隻有一個BIT為ON，繼續掃描；若不等則有多個BIT，以後者為主
       				if(wIndex1 == wIndex2) continue;
       				else
       				{
       					_ClearBit(wErrorFlag,wIndex2);
       					cIndex = (char)i*16 + (char)wIndex1; 
       					iResult = (int)cIndex;		//用iResult傳遞Assign!!
       					m_iRealIndex = iResult;
        				wErrorStrIndex = g_pExTable->GetTableValue(CNT_TABLE_ERROR,(int*)&iResult,&dbeflg); //再用iResult得到反饋結果(優先級)
       					break;
       				}	        			
        		}	
        	else	break;
        }
    }
	if (cIndex != tmERROR_NULL)
    {
    	if(b_AlarmState)	//James add 2008/4/14 10:49上午  提示Error不ShowAlarm
			g_wErrorStatus = TRUE;
    
    	if (dbbuff.cIndexError != cIndex)
        {
        	if (dbbuff.cIndexMode != tmMODE_AUTOADJMOLD)
            {
            	if ((dbbuff.cIndexMode == tmMODE_SEMIAUTO) && (cIndex == (ERR_0E_PLSCLSDOOR - ERR_BEGIN)))               
                {
	                dbbuff.bDelayedSpeech = TRUE;
	                dbbuff.lDelayedCount  = SPEECH_DELAYEDCOUNT;   
	                dbbuff.bRepeatSpeech  = FALSE;         
                }
            	else
                {
	                dbbuff.bDelayedSpeech = FALSE;
	                //::Speech(cIndex); 
	                if ((dbbuff.cIndexMode == tmMODE_SEMIAUTO) && (cIndex == (ERR_0D_PLSOPNDOOR - ERR_BEGIN)))
	                    dbbuff.bRepeatSpeech  = FALSE;
	                else
                    {
                    	dbbuff.bRepeatSpeech  = TRUE;
                    	dbbuff.lRepeatCount   = SPEECH_REPEATCOUNT; 
                    }
                }
            }
			if(m_nErrorCount == 0)
				Prompt(g_MultiLanguage[wErrorStrIndex],1);  //標準之錯誤字串顯示
     	dbbuff.cIndexError = cIndex;
        }
    	else  //dbbuff.cIndexError != cIndex
        {
        	if ((dbbuff.cIndexMode == tmMODE_SEMIAUTO) && (cIndex == (ERR_0E_PLSCLSDOOR - ERR_BEGIN)) && (dbbuff.bDelayedSpeech) && (dbbuff.lDelayedCount <= 0))
            {
	            dbbuff.bDelayedSpeech = FALSE;
	            dbbuff.bRepeatSpeech  = TRUE;
	            dbbuff.lRepeatCount   = SPEECH_REPEATCOUNT;   
            }
        	else if ((dbbuff.bRepeatSpeech) && (dbbuff.lRepeatCount <= 0))
            {
	            dbbuff.lRepeatCount   = SPEECH_REPEATCOUNT; 
            }
	       	{
	        	if(m_nErrorCount == 0)
		        	Prompt(g_MultiLanguage[wErrorStrIndex],1); //標準之錯誤字串顯示
	       	}
        	dbbuff.cIndexError = cIndex;
       		//    }
        }       
    }
	else  //cIndex==ERROR_NULL
    {
    	
	    g_wErrorStatus = FALSE;
	    if (dbbuff.cIndexError != cIndex)
        {
	        Prompt(g_MultiLanguage[wErrorStrIndex]);
	        g_pMainFrame->GetCurrentView()->OnLoseFocus();
	        g_pMainFrame->GetCurrentView()->OnGetFocus();    
	        dbbuff.cIndexError = cIndex;
					b_PromptBar = TRUE; ///Andy 20100723       
        }
      else ///Andy 20100723
      	{
      		if(b_PromptBar)
      			{
      				//JOYCE2011-4-11 if(!b_Error2)		//fuxy, 2010-10-9 
      				if(m_nErrorCount == 0)
      				{
      					g_pMainFrame->GetPromptBar()->ShowAlarm(FALSE);
      					SendMsg(MSG_USER_SH_ERROR_FIX, 0xFFFFFFFF, 0xFFFFFFFF, NULL);
      				}
      				b_PromptBar = FALSE; 
      			}	
      	}
    }
*/
/*
	for (i = 0; i < tmMAX_OP_ERRORSAVE+2; i++)//改為掃描16個WORD
    {    	
			if((wDSPLIBDaysCode>=0x1831)&&(wDSPLIBYearCode==0x2011)||(wDSPLIBYearCode>=0x2012)) 
				{
    		if(i == 12) continue;//第13個WORD要跳過去,error2的E40取代STAT.ERROR+12 //JOYCE2011-10-12
    		}

    	dwIndex = g_pDatabase->DataIDToIndex(dwID+i);

			if((i == 15) && (GetDBValue(dwIndex).lValue & 0x8000)) continue;//JOYCE2013-10-11 ERROR+15的BIT15要跳過去,DSP把它作為 驅動器溫度狀態的warning flag 

			if(!g_pExTable->GetTableValue(0,"D_TP2MTP") && ((wDSPLIBDaysCode<0x4401)&&(wDSPLIBYearCode==0x2014)||(wDSPLIBYearCode<=0x2013))) //  無料溫, 料溫作模溫
			{	
				if(i == 0)//JOYCE2011-11-8 循環警報方式bug修正:當ER0_TEMP為1,1C8如果有變化(由0變為8;由8變為0),則會出現無法消除警報'模溫偏差'或'溫度偏差'
				{					
					dwValue = GetDBValue("STATE_ALARM_ON_STEP1_ERRORDATA").lValue;
				  if(dwValue & 0x0001)  //ER0_TEMP  .SET     0   ; '溫度偏差      '        		
				  	{
						dwValue = GetDBValue("MACH_OTHR_OTHR_NULL_WERRORSTATUS1").lValue;
				  	if(dwValue & 0x0008)
				  		{	
				  		if(wTempFlag == 0)
				  			{
				  			wMoldTempErrStrIndex = g_MultiLanguage.GetStrKeyIndex("ERR_B6_ALARMC06");//模溫偏差
				  			wMoldTempFlag = 1;
				  			}	
				  		else	if(wTempFlag == 1)
				  			{
				  			wTempFlag = 2;
				  			}
				  		}
				  	else 
				  		{		  		
				  		if(wMoldTempFlag == 0)
				  			{
					  		wTempErrStrIndex = g_MultiLanguage.GetStrKeyIndex("ERR_0F_TEMPERR");//溫度偏差
					  		wTempFlag = 1;
				  			}	
				  		else	if(wMoldTempFlag == 1)
				  			{
				  			wMoldTempFlag = 2;
				  			}
				  		}		
				  	}
				  else
				  	{
				  		if(wTempFlag == 1)
				  			{
				  			wTempFlag = 2;
				  			}
				  		if(wMoldTempFlag == 1)
				  			{
				  			wMoldTempFlag = 2;
				  			}
				  	}	
				}
			}

    	if(i == 14) 
    		{
    			wErrorFlag = dbeflg.wErrorFlag[i] ^ GetDBValue(dwIndex).lValue;
    			if(wErrorFlag&0x0020)//安全門不記錄,發生變化
    				{
    					if(bSPdoor)
    						{
    							dbeflg.wErrorFlag[0] &= 0xFFFD;
    							iResult = 1+0x100;
    							wErrorStrIndex	=	g_pExTable->GetTableValue(CNT_TABLE_ERROR,(int*)&iResult,&dbeflg);
    							if(iResult == 10)	
    								{
    									FixErrorLog((DWORD)wErrorStrIndex);
    								}	
    						}	
    					if(bSPbackdoor)
    						{
    							dbeflg.wErrorFlag[3] &= 0xBFFF;
    							iResult = 62+0x100;
    							wErrorStrIndex	=	g_pExTable->GetTableValue(CNT_TABLE_ERROR,(int*)&iResult,&dbeflg);
    							if(iResult == 10)	
    								{
    									FixErrorLog((DWORD)wErrorStrIndex);
    								}	
    						}
    				}
    			if(wErrorFlag&0x001F)
    				{
    					if(bSPcoreLoc)
    						{
    							dbeflg.wErrorFlag[1] &= 0xF7FF;
    							iResult = 27+0x100;
    							wErrorStrIndex	=	g_pExTable->GetTableValue(CNT_TABLE_ERROR,(int*)&iResult,&dbeflg);
    							if(iResult == 10)	FixErrorLog((DWORD)wErrorStrIndex);
    						}	
    					else	if(bSPcorePos)
    						{
    							dbeflg.wErrorFlag[2] &= 0xFFF7;
    							iResult = 35+0x100;
    							wErrorStrIndex	=	g_pExTable->GetTableValue(CNT_TABLE_ERROR,(int*)&iResult,&dbeflg);
    							if(iResult == 10)	FixErrorLog((DWORD)wErrorStrIndex);
    						}	
    					else	if(bSProbot)
    						{
    							dbeflg.wErrorFlag[2] &= 0xFDFF;
    							iResult = 41+0x100;
    							wErrorStrIndex	=	g_pExTable->GetTableValue(CNT_TABLE_ERROR,(int*)&iResult,&dbeflg);
    							if(iResult == 10)	FixErrorLog((DWORD)wErrorStrIndex);
    						}	
    				}
    			dbeflg.wErrorFlag[i] = GetDBValue(dwIndex).lValue; 
    			continue;//第15個WORD要跳過去
    		}	
    	//printf("a:%d, wErrorFlag:%X,buf:%X,db:%X\n",i,wErrorFlag,dbeflg.wErrorFlag[i],GetDBValue(dwIndex).lValue);
      wErrorFlag = dbeflg.wErrorFlag[i] ^ GetDBValue(dwIndex).lValue;
      switch(i)
      	{
      		case	0:
      			if((~wErrorFlag&0x0002)&&(dbeflg.wErrorFlag[i]&0x0002))	bSPdoor 	 = TRUE;
      			break;
      		case	1:
      			if((~wErrorFlag&0x0800)&&(dbeflg.wErrorFlag[i]&0x0800))	bSPcoreLoc = TRUE;        			
      			break;
      		case	2:
      			if((~wErrorFlag&0x0008)&&(dbeflg.wErrorFlag[i]&0x0008))	
      				if(!bSPcoreLoc&&!bSProbot)	bSPcorePos = TRUE; //條件必須互斥,否則就掛了
      			if((~wErrorFlag&0x0200)&&(dbeflg.wErrorFlag[i]&0x0200))	
      				if(!bSPcoreLoc&&!bSPcorePos)	bSProbot	 = TRUE;
      			break;
      		case	3:
      			if((~wErrorFlag&0x4000)&&(dbeflg.wErrorFlag[i]&0x4000))	bSPbackdoor = TRUE;
      			break;
      		default:
      			break;
      	}
    	if (wErrorFlag)
       	{
        	dbeflg.wErrorFlag[i] = GetDBValue(dwIndex).lValue; //第一次發生進來會先存入,做為第二次還原時間(FixErrorLog)之用 
        	  //printf("b:%d, wErrorFlag:%X,buf:%X,db:%X\n",i,wErrorFlag,dbeflg.wErrorFlag[i],GetDBValue(dwIndex).lValue);
        	while (wErrorFlag)            //多個ERROR同時發生要全部都紀錄!
			{
				//g_tmDebugInfo->PrintDebugInfo("Error Index1 = 619\n");
	            cIndex = (char)_ScanBitF(wErrorFlag);
	            RealIndex=cIndex + i*16;  //先記憶體存住,可免相同使用之判斷式都重算
	            //printf("RealIndex=%d g_wErrorStatus=%d b_AlarmState=%d \n", RealIndex, g_wErrorStatus, b_AlarmState);
							iResult = (int)RealIndex;
							m_iRealIndex = iResult;
							wErrorStrIndex	=	g_pExTable->GetTableValue(CNT_TABLE_ERROR,(int*)&iResult,&dbeflg);
							//printf("result: %d,RealIndex: %d dbeflg.wErrorFlag[%d ]=%d dwIndex=%d \n",iResult,RealIndex , i, dbeflg.wErrorFlag[i], dwIndex);
							if(iResult <= 1)
            	{   
	                wErrorFlag = _ClearBit(wErrorFlag, cIndex); //先清掉該BIT再繼續
	                g_wErrorStatus = FALSE;
	                b_AlarmState = FALSE;
	                continue;      //不存入紀錄檔的例外狀況
            	}
            	else			//James add 2008/4/14 10:49上午  提示Error不ShowAlarm
            	{
	            	g_wErrorStatus = TRUE;
	            	b_AlarmState = TRUE;
            	}
	            if (_TestBit(GetDBValue(dwIndex).lValue, cIndex))	
	            {
	            	if(m_nErrorCount == 0)
		            	Prompt(g_MultiLanguage[wErrorStrIndex],1); //標準之錯誤字串顯示
	            	AddErrorLog((DWORD)wErrorStrIndex);
	            }
	            else
            	{
								if(!g_pExTable->GetTableValue(0,"D_TP2MTP") && ((wDSPLIBDaysCode<0x4401)&&(wDSPLIBYearCode==0x2014)||(wDSPLIBYearCode<=0x2013)))  //  無料溫, 料溫作模溫
								{
		            	if(wMoldTempFlag == 2)//模溫偏差 //JOYCE2011-11-8 
		            		{
		            		wMoldTempFlag = 0;
		            		FixErrorLog((DWORD)wMoldTempErrStrIndex);
		            		}
		            	else	if(wTempFlag == 2)//溫度偏差 //JOYCE2011-11-8 
		            		{
		            		wTempFlag = 0;
		            		FixErrorLog((DWORD)wTempErrStrIndex);
		            		}
		            	else
		            	FixErrorLog((DWORD)wErrorStrIndex);
								}
								else
								{
	            		FixErrorLog((DWORD)wErrorStrIndex);
								}		
            	}
            	wErrorFlag = _ClearBit(wErrorFlag, cIndex);
			}
		}
		}
*/
	//新增ERROR2處理方式 //JOYCE2010-7-9 
	//if((wDSPLIBDaysCode>=0x0707)&&(wDSPLIBYearCode==0x2010)||(wDSPLIBYearCode>=0x2011)) 
	//{
		Error_Control2_New();
	//}

	if (g_pExTable->GetTableValue(0,"D_MUCELL"))//JOYCE2010-12-16 
	{
		printf("Rs485Error_Control_New\n");
		Rs485Error_Control_New();
	}

	if(1 == CtmConfig::GetInstance()->GetN2CFlag()) /*JOYCE2014-8-21*/
	{
		printf("N2CError_Control\n");
	 	N2CError_Control();
	}
	//Error_Control_55M3();
	if(CtmConfig::GetInstance()->GetDspCom2Flag() == 5)/*JOYCE2015-10-29機械手一體化*/
	{
		Rbt485Error_Control();
	}
	Error_Control_Card();

	RollError();	//Caozz add 2011/3/28 下午 04:30:21
}

void   	CtmControl_Error::Error_Control2_New()
{
	short		i;
	WORD		cIndex = 0xFFFF, RealIndex;
	WORD		wErrorFlag;	
	WORD		wErrorStrIndex = g_MultiLanguage.GetStrKeyIndex("MSG_DUMMY");
	DWORD		dwID, dwIndex;
	int			iResult = 0;
	BOOL    bError2Flag = 0;

	dwID = g_pDatabase->GetDataID("STATE_ALARM2_ON_STEP1_ERRORDATA");	 	
	 	
	for (i = 0; i < 8; i++)
	{
	 	dwIndex = g_pDatabase->DataIDToIndex(dwID+i);
	 	if ((wErrorFlag = GetDBValue(dwIndex).lValue) >= 0x100)
	 		{
	        	b_Error2 = TRUE;	//fuxy, 2010-10-9 
	        	cIndex  = GetDBValue(dwIndex).lValue;  // Scan the 1's bit from left to right (Reverse)
	        	m_iRealIndex = (int)cIndex;		//用iResult傳遞Assign!!
	        	iResult = m_iRealIndex + 0x10000000;//以表示error2
	        	wErrorStrIndex = g_pExTable->GetTableValue(CNT_TABLE_ERROR,(int*)&iResult,&dbeflg); //再用iResult得到反饋結果(優先級)
	 		}
	 	else break;
	}
		//show error
		if (cIndex != 0xFFFF)
	    {
	    	if(b_AlarmState)	//James add 2008/4/14 10:49上午  提示Error不ShowAlarm
				g_wErrorStatus = TRUE;
       	if(m_nErrorCount == 0)
		     	Prompt(g_MultiLanguage[wErrorStrIndex],1);
	     	dbbuff.cIndexError2 = cIndex;
	    }
		else  //cIndex==ERROR_NULL
	    {    	
		    if(b_Error2)/*JOYCE2011-11-24 不加此條件,導致bug:面板上顯示有警報,iNet的機器群覽畫面,沒有顯示警報狀態*/
			    g_wErrorStatus = FALSE;
		    b_Error2 = FALSE;		//fuxy, 2010-10-9 
		    if (dbbuff.cIndexError2 != cIndex)
	        {
		        Prompt(g_MultiLanguage[wErrorStrIndex]);
		        g_pMainFrame->GetCurrentView()->OnLoseFocus();
		        g_pMainFrame->GetCurrentView()->OnGetFocus();    
		        dbbuff.cIndexError2 = cIndex;
						b_PromptBar = TRUE; //JOYCE2010-10-22        
	        }
      else //JOYCE2010-10-22 
      	{
      		if(b_PromptBar) 
      			{
     					if(m_nErrorCount == 0)
     					{
     						g_pMainFrame->GetPromptBar()->ShowAlarm(FALSE);
     						SendMsg(MSG_USER_SH_ERROR_FIX, 0xFFFFFFFF, 0xFFFFFFFF, NULL);
      				}
      				b_PromptBar = FALSE; 
      			}	
      	}
	    }		

		//record error
	for (i = 0; i < 8; i++)//改為掃描8個WORD
    {    	
    	dwIndex = g_pDatabase->DataIDToIndex(dwID+i);
    	
    	if (dbeflg.wErrorFlag2[i] != GetDBValue(dwIndex).lValue)//error2,是以序號來標識,一個值表示一個警報,新舊值不同時進行處理
       	{
					if((dbeflg.wErrorFlag2[i] != 0)&&(GetDBValue(dwIndex).lValue != 0))//新舊值都不為0
						{
						wErrorFlag = GetDBValue(dwIndex).lValue;
						bError2Flag = TRUE;
						}
					else//新舊值,其中一個為0
						{
			    	wErrorFlag = dbeflg.wErrorFlag2[i] ^ GetDBValue(dwIndex).lValue;
						bError2Flag = FALSE;
						}
						
       		dbeflg.wErrorFlag2[i] = GetDBValue(dwIndex).lValue; //第一次發生進來會先存入,做為第二次還原時間(FixErrorLog)之用 
        	RealIndex=wErrorFlag;  //先記憶體存住,可免相同使用之判斷式都重算
					iResult = (int)RealIndex+0x10000000;//以表示error2
					m_iRealIndex = RealIndex;
					wErrorStrIndex	=	g_pExTable->GetTableValue(CNT_TABLE_ERROR,(int*)&iResult,&dbeflg);
					//printf("result: %d,RealIndex: %d dbeflg.wErrorFlag2[%d ]=%d dwIndex=%d \n",iResult,RealIndex , i, dbeflg.wErrorFlag2[i], dwIndex);
					if(iResult <= 1)
          {   
	            g_wErrorStatus = FALSE;
	            b_AlarmState = FALSE;
	            continue;      //不存入紀錄檔的例外狀況
          }
          else			//James add 2008/4/14 10:49上午  提示Error不ShowAlarm
          {
	        	g_wErrorStatus = TRUE;
	        	b_AlarmState = TRUE;
          }

	        if (GetDBValue(dwIndex).lValue)	
	        {
	        	if(bError2Flag)//新舊值都不為0,需先清除舊警報
	        		FixErrorLog((DWORD)wOldErrorStrIndex[i]);	            	

	         	if(m_nErrorCount == 0)
		        	Prompt(g_MultiLanguage[wErrorStrIndex],1); //標準之錯誤字串顯示
	        	AddErrorLog((DWORD)wErrorStrIndex);
	        }
	        else
          {	        	
	        	FixErrorLog((DWORD)wErrorStrIndex);	            	
         	}

					wOldErrorStrIndex[i] = wErrorStrIndex;
				}
		}		
}
/*
void	CtmControl_Error::Rbt485Error_Control()
{
	memset(&sysStat,  0,  sizeof(sysStat));	
	if(g_ptaskPickerComm != NULL)
		g_ptaskPickerComm->RequestData(RBOT_SYS_STAT,  &sysStat,  sizeof(sysStat));

	DWORD dwErrorID = sysStat.sys_error;//bit0~bit6

	static	BOOL bShowFlag = FALSE;
	static	DWORD	dwOldErrorID = 0;
	DWORD	dwTempValue = ERROR_ROBOT_RS485;

	//printf("Rbt485Error_Control()   dwErrorID=%x\n", dwErrorID);
	
	if(dwErrorID > 0 && (dwErrorID & 0x0000007F) > 0 && dwErrorID < 0xFFFFFFFF)
	{
		if(dwOldErrorID != dwErrorID && dwOldErrorID != 0)
		{
			DWORD dwIndex = 0;
			DWORD wRbtErrorFlag = (dwOldErrorID&dwErrorID) ^ dwOldErrorID;
			for(int i=0; i<RbtMaxErrorCnt; i++)
			{
				dwIndex = _TestBit(wRbtErrorFlag, i);

				if(dwIndex)
				{
					dwIndex = 1 << i;
					dwIndex += dwTempValue << 24;
					//printf("111 dwIndex=%x\n", dwIndex);
					FixErrorLog((DWORD)dwIndex, tmRobotRS485_ERRORFLAG);
				}
			}
			
		}
		
		if(bShowFlag == FALSE || dwOldErrorID != dwErrorID)
		{
			DWORD dwIndex = 0;
			DWORD wRbtErrorFlag = (dwOldErrorID&dwErrorID) ^ dwErrorID;

			for(int i=0; i<RbtMaxErrorCnt; i++)
			{
				dwIndex = _TestBit(wRbtErrorFlag, i);

				if(dwIndex)
				{
					dwIndex = 1 << i;
					dwIndex += dwTempValue << 24;
					//printf("222 dwIndex=%x\n", dwIndex);
					g_ptmControlServer->ErrorControl()->AddErrorLog((DWORD)dwIndex, tmRobotRS485_ERRORFLAG);
				}
			}
		}
		
		dwOldErrorID = dwErrorID;
		bShowFlag = TRUE;
	}
	else
	{
		if(bShowFlag == TRUE)
		{
			bShowFlag = FALSE;

			DWORD dwIndex = 0;
			for(int i=0; i<RbtMaxErrorCnt; i++)
			{
				dwIndex = _TestBit(dwOldErrorID, i);

				if(dwIndex)
				{
					dwIndex = 1 << i;
					dwIndex += dwTempValue << 24;
					//printf("333 dwIndex=%x\n", dwIndex);
					FixErrorLog((DWORD)dwIndex, tmRobotRS485_ERRORFLAG);
				}
			}
			dwOldErrorID = dwErrorID;
		}	
	}
}

void	CtmControl_Error::Rs485Error_Control_New()
{
	DWORD dwErrorID = GetDBValue("SYSX_OTHERS_OTHERS_NULL_RESERVED67").lValue;
	DWORD dwErrorID1 = 0;
	static	BOOL 	bShowFlag = FALSE, bErrorFlag = FALSE;
	static	DWORD	dwOldErrorID = 0;
	DWORD		dwTempValue = ERROR_OBJECT_RS485;

	if(!GetDBValue("MSET_SCRW_RCV_NULL_W046F").lValue)		//儲料注氣不用 
	{
		dwErrorID = 0x0000FFFF;			//fuxy, 2011-8-24 
	}

	DWORD		dwTempErrorID = dwErrorID & 0x0000FFFF;
	DWORD		dwOldTempErrorID = dwOldErrorID & 0x0000FFFF;

	char szStrID[64];
	sprintf(szStrID, "ERR_MUCELL_%d", dwErrorID);
	dwErrorID1 =  g_MultiLanguage.GetStrKeyIndex(szStrID);
	//printf("dwErrorID1:%d, %d\n", dwErrorID1, dwErrorID);
	
	if((dwErrorID > 0 || dwErrorID == 0) && (dwTempErrorID < 0xFFFF))
	{
		if(dwTempErrorID >= 4000)	//2012-6-15, add 
		{
			if(GetDBValue("SYSX_OTHERS_OTHERS_INT_RESERVED12").lValue == 2)		
		 		SetDBValue("SYSX_OTHERS_OTHERS_INT_RESERVED12", 0, FALSE);
		}
		
		dwErrorID +=  dwTempValue << 24;
		
		if(dwOldErrorID != dwErrorID && dwOldErrorID != 0 && (dwOldTempErrorID >= 4000)) //4000以上為警報
		{
			FixErrorLog((DWORD)dwOldErrorID,tmRS485_ERRORFLAG);
		}
		if((bShowFlag == FALSE || dwOldErrorID != dwErrorID) && (dwTempErrorID >= 4000)
			 && (GetDBValue("MACH_OTHR_OTHR_NULL_SPECIALDATA47").lValue != 0x8001))		//fuxy, 2012-3-13  液壓調校  警報 
		{
			g_ptmControlServer->ErrorControl()->AddErrorLog((DWORD)dwErrorID,tmRS485_ERRORFLAG);
			bErrorFlag = TRUE;
			b_PromptBar= TRUE;
		}
		
		if((dbbuff.cIndexError == tmERROR_NULL) && (dbbuff.cIndexError2 == 0xFFFF)
			 &&(GetDBValue("MACH_OTHR_OTHR_NULL_SPECIALDATA47").lValue != 0x8001)		//JOYCE2011-4-26 清理打氣頭message first,,否則兩個警報會來回閃動
			 &&(dwTempErrorID < 4000) )   //stat.error沒有警報時才show mucell 提示信息  //fuxy, 2012-3-13  液壓調校  提示信息
		{
			if((dwErrorID1 != -1) &&(dwErrorID1 != 0xFFFFFFFF))		//2012-6-15, add for Not defined alarm 
			{
				if(GetDBValue("SYSX_OTHERS_OTHERS_INT_RESERVED12").lValue == 2)
				{
					if((dwTempErrorID != 2010) &&(dwTempErrorID != 2020) &&(dwTempErrorID != 2030) &&(dwTempErrorID != 2040) &&(dwTempErrorID != 2050)&&(dwTempErrorID != 2060))
					{
						SetDBValue("SYSX_OTHERS_OTHERS_INT_RESERVED12", 0, FALSE);
						SendMsg(MSG_USER_SH_PROMPTERROR, dwErrorID1, 0, NULL);
					}
				}
				else
					SendMsg(MSG_USER_SH_PROMPTERROR, dwErrorID1, 0, NULL);
			}
			if((m_nErrorCount == 0)&&(bErrorFlag))
				{
					g_pMainFrame->GetPromptBar()->ShowAlarm(FALSE);		//fuxy, 2012-1-12, for  警報紅條 
					SendMsg(MSG_USER_SH_ERROR_FIX, 0xFFFFFFFF, 0xFFFFFFFF, NULL);
					bErrorFlag = FALSE;
				}
		}
	
		dwOldErrorID = dwErrorID;
		bShowFlag = TRUE;
	}
	else
	{
		if(!GetDBValue("MSET_SCRW_RCV_NULL_W046F").lValue)	//fuxy, 2011-8-24,儲料注氣不用  
		{
			if(bShowFlag == TRUE)
			{
				bShowFlag = FALSE;
				if(GetDBValue("SYSX_OTHERS_OTHERS_NULL_RESERVED67").lValue  >= 4000)	//原來為警報 
					FixErrorLog(dwOldErrorID,tmRS485_ERRORFLAG);
    			if((dbbuff.cIndexError == tmERROR_NULL) && (dbbuff.cIndexError2 == 0xFFFF))		//54沒有警報 
    			{
    				g_pMainFrame->GetPromptBar()->ShowAlarm(FALSE);	//fuxy, 2012-1-12, for  警報紅條  
    				SendMsg(MSG_USER_SH_ERROR_FIX, 0xFFFFFFFF, 0xFFFFFFFF, NULL);		//警報條消除 
    			}
			}
		}
		else
		{
			if(bShowFlag == TRUE)
			{
				bShowFlag = FALSE;
				if(bErrorFlag == TRUE)
				{
					bErrorFlag = FALSE;
					FixErrorLog((DWORD)dwOldErrorID,tmRS485_ERRORFLAG);
				}
			}
		}
	}
	
}
*/
void	CtmControl_Error::N2CError_Control()/*JOYCE2014-8-21*/
{
	DWORD dwErrorID;
	if(GetDBValue("MCONF_OTHERS_OTHERS_NULL_RESERVED32").lValue == 1)/*編碼器液壓轉盤*/
	dwErrorID = GetDBValue("MACH_OTHR_OTHR_NULL_W3EC8").lValue;
	else
	dwErrorID= GetDBValue("AUSTON_ACTUALDATA_DWERROR").lValue;/*N2C(50038)*/

	static	BOOL bShowFlag = FALSE;
	static	DWORD	dwOldErrorID = 0;
	DWORD		dwTempValue = ERROR_OBJECT_N2C;

	dwErrorID += dwTempValue << 24;
	
	if(dwErrorID > 0x00010000 && (dwErrorID & 0x0000FFFF) > 0 && dwErrorID < 0xFFFFFFFF)
	{
		if(dwOldErrorID != dwErrorID && dwOldErrorID != 0)
		{
			FixErrorLog((DWORD)dwOldErrorID, tmN2C_ERRORFLAG);
		}
		
		if(bShowFlag == FALSE || dwOldErrorID != dwErrorID)
		{
			g_ptmControlServer->ErrorControl()->AddErrorLog((DWORD)dwErrorID, tmN2C_ERRORFLAG);
		}
		dwOldErrorID = dwErrorID;
		bShowFlag = TRUE;
		g_wErrorStatus_Dsp28 = TRUE;
	}
	else
	{
		if(bShowFlag == TRUE)
		{
			bShowFlag = FALSE;

			FixErrorLog((DWORD)dwOldErrorID, tmN2C_ERRORFLAG);
			g_wErrorStatus_Dsp28 = FALSE;
		}	
	}
}

//Caozz 2011/4/14 上午 11:17:01
int	CtmControl_Error::ParseErrorID(char* pszErrorStr, DWORD dwErrorID)
{
	WORD    *pwDst, *pwSrc;
	pwDst = (WORD *)pszErrorStr; 
	
	int 	j = 0;
	if((dwErrorID & 0xFFFF0000) == 0)	//54警報  //高word為0
	{
		pwSrc    = (WORD *)g_MultiLanguage[dwErrorID];
		
		if(pwSrc != NULL)
		while(*pwSrc != 0 && j < 256)
		{
		    *pwDst ++   = *pwSrc ++;
		    j++;
		}
		*pwDst = 0;
		return j * 2;
	}
	//other警報  //高word不為0
	BYTE byObject, bySubIndex;
	WORD wErrorID;
	byObject 	= (dwErrorID & 0xFF000000) >> 24; //source
	bySubIndex 	= (dwErrorID & 0x00FF0000) >> 16;//那個源,多連動時有多個Austone等
	wErrorID	= dwErrorID & 0x0000FFFF; 
	char szTemp[64], szStrID[64];
	memset(szTemp,0,sizeof(szTemp));
	memset(szStrID,0,sizeof(szStrID));
//printf("dwErrorID=%d,byObject=%d,bySubIndex=%d,wErrorID=%d\n",dwErrorID,byObject,bySubIndex,wErrorID);
	switch(byObject)
	{
		case ERROR_OBJECT_N2C:	
			if(GetDBValue("MCONF_OTHERS_OTHERS_NULL_RESERVED32").lValue == 1)/*JOYCE2014-8-21 編碼器液壓轉盤*/
			{
			sprintf(szTemp, "[R]");
			sprintf(szStrID, "ERR_ROTATE_%d", wErrorID);
			}
			else
			{	
			sprintf(szTemp, "[N%d]", bySubIndex);
			sprintf(szStrID, "N2C_ALARM%d", wErrorID);
			}
			//printf("N2C szStrID= %s\n", szStrID);
			return ErrorIDToStr(szTemp, szStrID ,wErrorID, pwDst);
			break;
		case ERROR_OBJECT_E2C:
			sprintf(szTemp, "[E%d]", bySubIndex);
			sprintf(szStrID, "E2C_ALARM%d", wErrorID);
			//printf("szStrID= %s\n", szStrID);
			return ErrorIDToStr(szTemp, szStrID ,wErrorID, pwDst);
			break;	
		case ERROR_OBJECT_AUSTONE:
			sprintf(szTemp, "[A%d]", bySubIndex);
			sprintf(szStrID, "AUSTONE_ALARM%d", wErrorID);
			//printf("szStrID= %s\n", szStrID);
			return ErrorIDToStr(szTemp, szStrID ,wErrorID, pwDst);
			break;
		case ERROR_OBJECT_SIEMENS:
			sprintf(szTemp, "[S%d]", bySubIndex);
			sprintf(szStrID, "SIEMENS_ALARM%d", wErrorID);
			//printf("szStrID= %s\n", szStrID);
			return ErrorIDToStr(szTemp, szStrID ,wErrorID, pwDst);
			break;
		case	ERROR_OBJECT_RS485:  //JOYCE2011-5-4 add for 7HT MUCELL
			sprintf(szTemp, "[M]");
			sprintf(szStrID, "ERR_MUCELL_%d", wErrorID);
			//printf("szStrID= %s\n", szStrID);
			return ErrorIDToStr(szTemp, szStrID ,wErrorID, pwDst);
			break;
		case ERROR_ROBOT_RS485:
			sprintf(szTemp, "[ROBOT]");
			sprintf(szStrID, "ERR_ROBOT_%d", wErrorID);
			//printf("szStrID= %s\n", szStrID);
			return ErrorIDToStr(szTemp, szStrID ,wErrorID, pwDst);
			break;	
		case ERROR_AMMETER_TM:			//Rw.ying 2013-1-31
			sprintf(szTemp, "[Amt%d]", bySubIndex+1);
			if((wErrorID&0xFF00) == 0)
				sprintf(szStrID, "AMMETER_ALARM%d", wErrorID);
			else if((wErrorID&0xFF00) == 0x100)
				sprintf(szStrID, "AMMETER_VO_ALARM%d", wErrorID&0xFF);

			return ErrorIDToStr(szTemp, szStrID ,wErrorID, pwDst);
			break;
		case ERROR_OBJECT_TM:
			sprintf(szTemp, "[T%d]", bySubIndex);
			sprintf(szStrID, "TM_ALARM%d", wErrorID);
			//printf("szStrID= %s\n", szStrID);
			return ErrorIDToStr(szTemp, szStrID ,wErrorID, pwDst);
			break;
//		case ERROR_OBJECT_55ERROR2:
//			sprintf(szTemp, "[55_%d]", bySubIndex);
//			sprintf(szStrID, "D55_2_%d", wErrorID);
//			//printf("szStrID= %s\n", szStrID);
//			return ErrorIDToStr(szTemp, szStrID ,wErrorID, pwDst);
//			break;
		case ERROR_OBJECT_M3ERROR:
			sprintf(szTemp, "[28_%d:%d]", bySubIndex, wErrorID);
			sprintf(szStrID, "M3_ALARM%d", wErrorID);
			//printf("szStrID= %s\n", szStrID);
			return ErrorIDToStr(szTemp, szStrID ,wErrorID, pwDst);
			break;
		default:
			sprintf(szTemp, "[Un %d,%d]", byObject,bySubIndex);
			sprintf(szStrID, "UNKNOWN_ALARM%d", wErrorID);
			//printf("szStrID= %s\n", szStrID);
			return ErrorIDToStr(szTemp, szStrID ,wErrorID, pwDst);
			break;	
	}
}
int	CtmControl_Error::ErrorIDToStr(char* szTemp, char* szStrID ,WORD wErrorID, WORD *pwDst)
{
	WORD   *pwSrc;
	int 	j = 0;
	if(g_MultiLanguage.GetStrKeyIndex(szStrID) == -1)
	{	
		sprintf(szTemp, "%s Error: %d", szTemp, wErrorID);
		while(*szTemp != 0)     
		{
			*pwDst ++ = *szTemp ++;
			j++;
		}
		*pwDst = 0;
		return j * 2;
	}
	else
	{
		while(*szTemp != 0)     
		{
			*pwDst ++ = *szTemp ++;
			j ++;
		}
//		*pwDst ++ =0x20;
//		j ++;
		pwSrc    = (WORD *)g_MultiLanguage[szStrID];
		if(pwSrc != NULL)
		while(*pwSrc != 0 && j < ERROR_STR_LEN/ERRORSTRMAX_NUM/2) /*joyce20130318*增加保護,限製單個字符串長度為50個字,防止數組越界(按tm編碼算,50個中文字/50個英文)*/
		{
		    *pwDst ++   = *pwSrc ++;
		    j ++;
		}
		*pwDst = 0;
		return j * 2;
	}
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Error::RollError()    	     		 				 |
|  Task     : 滾動顯示錯誤						     	                     |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:                           -                                    |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
void	CtmControl_Error::RollError() //JOYCE2011-4-11 
{
	static int nLan=-1;
	int nLanguageIndex = CtmConfig::GetInstance()->GetCurrentIndex();
	if(NULL == m_ErrorListHead)        	return;
	if(nLan!=nLanguageIndex)  /*wangli2016-4-5 13:59:08  修正切換語言，警報滾動顯示亂碼*/
	{
		nLan=nLanguageIndex;
		u_bErrorChangeFlag=TRUE;	
	}		
		
	int 		i = 0;
	static int 	nErrorStrLen = 0, nParseErrorLen = 0;
	char 		szErrorStr[512];
	char		szErrorNo[10];
	char   	 	pszTemp[8]={0} ;
	for(int i=0; i<sizeof(pszTemp);i+=2)
	{
		pszTemp[i]=' ';
	}	/*wangli2016-4-5 8:23:36 修正非矢量字體，當警報個數>10個，循環顯示一遍10個警報后，不會繼續循環顯示的問題*/
	static	int nUnicodeLen = 0, nUTFLen = 0;

	WORD		wErrorStrIndex = g_MultiLanguage.GetStrKeyIndex("MSG_DUMMY");

	memset(szErrorStr, 0, sizeof(szErrorStr));
	memset(szErrorNo, 0, sizeof(szErrorNo));
	
	tmErrorInfo* pCurrent = m_ErrorListHead->pNext;
	
	if(m_nErrorCount > 0)
	{
		if(!b_AddTimer)
		{
			::AddTimer(&l_lLoopTimer);
			b_AddTimer = TRUE;
		}
		
		if(m_nErrorCount == 1)
		{
			ParseErrorID(u_szErrorStr, pCurrent->dwErrorID);
			Prompt(u_szErrorStr,1);
		}
		else 
		{
			if(u_bErrorChangeFlag)
			{
				nErrorStrLen = 0;
				memset(u_szErrorStr, 0, sizeof(u_szErrorStr));
				for(i = 0; i < ERRORSTRMAX_NUM && NULL != pCurrent; i++)
				{
					if(pCurrent->dwErrorID > 0)
					{
						char szTemp[8];
						sprintf(szTemp, "%d. ", i+1);
						CodeChange(szErrorNo, szTemp);
						
						memcpy(u_szErrorStr + nErrorStrLen, szErrorNo, 6);
						//memcpy(u_szErrorStr + nErrorStrLen, szTemp, strlen(szTemp));
						nErrorStrLen += 6;
						
						nParseErrorLen = ParseErrorID(szErrorStr, pCurrent->dwErrorID);
						memcpy(u_szErrorStr + nErrorStrLen, szErrorStr, nParseErrorLen);	
						nErrorStrLen += nParseErrorLen;
						
						memcpy(u_szErrorStr + nErrorStrLen, pszTemp, sizeof(pszTemp));	
						nErrorStrLen += sizeof(pszTemp);
						
					}
					pCurrent = pCurrent->pNext;
				}
				Prompt(u_szErrorStr,1);
				if(CtmConfig::GetInstance()->GetLanguageType() == 1)	//蛌峈Unicode
				{
					char*	pwch2=NULL;
					char	m_szUN[1024];
					char*	pszString = u_szErrorStr;
					
					memset(m_szUN,0,sizeof(m_szUN));
					char* temp=m_szUN;
					WORD* pCode   = (WORD *)pszString;
					while(*pCode != 0x0000)
					{
					*temp=pszString[0];
					if(pszString[1]!=0)
					{
					 	*++temp=pszString[1];		
					}
					++temp;
					++pCode;
					++++pszString;	
					}
					pwch2=m_szUN;
					
					CtmEncode encode=CtmEncode("utf-8","utf-8");
					int nLength	= (strlen(pwch2)+2)*4;
					
					nUnicodeLen = encode.Utf8ConvertUnicode((unsigned char*)pwch2,u_Unicode, &nUTFLen);
					if(CtmConfig::GetInstance()->GetFontConvert())
					{
						encode.CovertToUnicodeTable(u_Unicode,nUnicodeLen);
					}
				}
			}
			if(l_lLoopTimer < 0)
			{
				//char* pszErrorTemp = u_szErrorStr;
				if(CtmConfig::GetInstance()->GetLanguageType() != 1)
				{
					char szError[1024];
					memset(szError,0,sizeof(szError));
					char* pszErrorTemp = u_szErrorStr;
					memcpy(pszErrorTemp + nErrorStrLen, pszErrorTemp, sizeof(WORD));
					int nLen =0;
					
					while(*(WORD*)pszErrorTemp != 0)
					{
						nLen++;
						memcpy(pszErrorTemp, pszErrorTemp + sizeof(WORD), sizeof(WORD));
						pszErrorTemp += sizeof(WORD);
					}
					//*(WORD*)pszErrorTemp = 0;
					memcpy(szError, pszErrorTemp, nLen<<1);  //20160330 /*wangli2016-4-5 8:23:36 修正非矢量字體，當警報個數>10個，循環顯示一遍10個警報后，不會繼續循環顯示的問題*/
					Prompt(u_szErrorStr,1);
				}
				else
				{
					CtmEncode encode=CtmEncode("utf-8","utf-8");
					unsigned long* unicodetemp = u_Unicode;
					unsigned long  unicodevalue = 0;
					unicodevalue = *unicodetemp;
					while(*unicodetemp != 0)
					{
						memcpy(unicodetemp, unicodetemp + 1, sizeof(long));
						unicodetemp++;
					}
					*(unicodetemp-1) = unicodevalue;
					
					char szTempStr[2*1024];
					memset(szTempStr, 0, sizeof(szTempStr));	
					encode.UnicodeConvertUtf8(u_Unicode,(unsigned char*)szTempStr);		
					Prompt(szTempStr,1);		
				}
				l_lLoopTimer = ERRORLOOPTIMER;
				u_bErrorChangeFlag = FALSE;
			}
			
		}
	}
	else 
	{
		if(b_AddTimer)
		{
			::DeleteTimer(&l_lLoopTimer);
			b_AddTimer = FALSE;
			Prompt(g_MultiLanguage[wErrorStrIndex], 0, 1);
      g_pMainFrame->GetCurrentView()->OnLoseFocus();
      g_pMainFrame->GetCurrentView()->OnGetFocus();    
		}	
	}	
}

BOOL    CtmControl_Error::ChangeErrorList(DWORD dwErrorID, WORD wSource, WORD wGrade, int nFlag)//JOYCE2011-4-11 
{
	if(m_nErrorCount > ERRORLISTMAX_NUM && nFlag == 1) return FALSE;
	if(NULL == m_ErrorListHead)        	return FALSE;	
	
	tmErrorInfo* pCurrent = m_ErrorListHead->pNext;
	tmErrorInfo* pBack 	  = m_ErrorListHead;
	
	tmErrorInfo* pTemp = NULL;	
	if(nFlag == 1) //AddErrorLog()
	{
		while(NULL != pCurrent)
		{
			if(wGrade > pCurrent->wGrade) break;
			pBack = pCurrent; 
			pCurrent = pCurrent->pNext;
		}
		
		pTemp =(tmErrorInfo*)malloc(sizeof(tmErrorInfo));
		pTemp->wSource 		= wSource;
		pTemp->wGrade 		= wGrade;
		pTemp->dwErrorID	= dwErrorID;
		pTemp->pNext 		= pBack->pNext;
		pBack->pNext		= pTemp;
		
		m_nErrorCount ++;
		u_bErrorChangeFlag = TRUE;
		
		return TRUE;/*JOYCE2014-9-3*/
	}
	else if(nFlag == 0) //FixErrorLog()
	{
		while(NULL != pCurrent)
		{
			if (pCurrent->dwErrorID == dwErrorID)
			{
				pBack->pNext = pCurrent->pNext;
				free(pCurrent);
				m_nErrorCount -- ;
				u_bErrorChangeFlag = TRUE;
				return TRUE;	
			}
			pBack = pCurrent; 
			pCurrent = pCurrent->pNext;
		}	
	}
	return FALSE;
}
/*---------------------------------------------------------------------------+
|  Function : CtmControl_Error::FixErrorLog(WORD wID)        	     		 |
|  Task     : Fix Error Index						     	                 |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:      WID                  -    Error ID                        |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
BOOL    CtmControl_Error::FixErrorLog(DWORD dwID, WORD	wSource)
{
	WORD        i;                                                                               
	WORD        wnIndex = m_MsgIndex.wIndex  + 1;
	
	pthread_mutex_lock(&m_MutexErrMsg);
	
	 /*JOYCE2015-2-2 bug修正:當只存在提示性警報時,警報圖標沒有清除的問題;保証 警報紅條和警報圖標同步*/
	if(u_iAlarmNum > 0)
		u_iAlarmNum--;
	//printf("FixErrorLog  u_iAlarmNum=%d\n",u_iAlarmNum);
	if(u_iAlarmNum == 0)
	{
	  g_wErrorStatus = FALSE;
  	b_AlarmState = FALSE;
	}
	
	for (i=0; i<m_MsgIndex.wCount; i++)
	{   
	     if ((short int)(--wnIndex) < 0)         //James modify 2009/6/8 狟敁 07:50:28  --wnIndex  ---wnIndex -1
	            wnIndex = CtmConfig::GetInstance()->GetErrorMaxNum()-1;
	
	    if(CtmConfig::GetInstance()->GetRecordType() == 1)
			CManageFile::GetInstance()->ReadRecord(FILE_RECORD_ALARM, wnIndex, &m_MsgCurrent, sizeof(m_MsgCurrent));
		else
			CtmSarmRecordFileControl::GetInstance()->ReadRecord(ID_ERROR_SRAMFILE, wnIndex, &m_MsgCurrent);	//2009-5-21
	
	    if ((m_MsgCurrent.OilError.dwID == dwID) && (m_MsgCurrent.OilError.dateFixed.year == 0) && (m_MsgCurrent.wSource == wSource))            //James modify 2007/9/11 06:02狟敁
	    {                                                                                    
	        GetDate(&m_MsgCurrent.OilError.dateFixed);                                           
	        GetTime(&m_MsgCurrent.OilError.timeFixed);
	        if(CtmConfig::GetInstance()->GetRecordType() == 1)
				CManageFile::GetInstance()->WriteRecord(FILE_RECORD_ALARM, wnIndex, &m_MsgCurrent, sizeof(m_MsgCurrent));
			else
				CtmSarmRecordFileControl::GetInstance()->WriteRecord(ID_ERROR_SRAMFILE, wnIndex, &m_MsgCurrent);//2009-5-21	
	
    			g_pMainFrame->GetPromptBar()->ShowAlarm(FALSE);
    			SendMsg(MSG_USER_SH_ERROR_FIX, wnIndex, m_iRealIndex, NULL);
	
	        ChangeErrorList(dwID, wSource, 0, 0);//JOYCE2011-4-11 
	        pthread_mutex_unlock(&m_MutexErrMsg);                                                
	        return TRUE;                                                                         
	     }
	}     
	ChangeErrorList(dwID, wSource, 0, 0);//JOYCE2011-4-11 
	g_pMainFrame->GetPromptBar()->ShowAlarm(FALSE);
	SendMsg(MSG_USER_SH_ERROR_FIX, 0xFFFFFFFF, 0xFFFFFFFF, NULL);
	
	pthread_mutex_unlock(&m_MutexErrMsg);                                                                                                                            
	
	return FALSE;
}
/*---------------------------------------------------------------------------+
|  Function : CtmControl_Error::GetErrorIndex()             	     		 |
|  Task     : Get Error Index						     	                 |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:         		            -                                    |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
void*	CtmControl_Error::GetErrorIndex()
{
	printf("GetErrorIndex 123\n");
	return &m_MsgIndex;	
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Error::GetErrorLog(int nIndex)     	     		 |
|  Task     : Get Error log							     	                 |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:  nIndex 		            - Error ID                           |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
void*	CtmControl_Error::GetErrorLog(int nIndex)
{
	printf("GetErrorLog  nIndex = %d\n",nIndex);
	memset(&m_MsgCurrent, 0, sizeof(m_MsgCurrent));
	if (nIndex > m_MsgIndex.wCount)
		return &m_MsgCurrent;
	printf("m_MsgIndex.wIndex = %d\n",m_MsgIndex.wIndex);
	nIndex = m_MsgIndex.wIndex - nIndex;
	printf("222GetErrorLog  nIndex = %d\n",nIndex);
	if (nIndex < 0)
		nIndex += CtmConfig::GetInstance()->GetErrorMaxNum();

	if(CtmConfig::GetInstance()->GetRecordType() == 1)
	{
		CManageFile::GetInstance()->ReadRecord(FILE_RECORD_ALARM, nIndex + 1, &m_MsgCurrent, sizeof(m_MsgCurrent));
		printf("nIndex:%d, wIndex:%d, dwShotCount:%x\n", nIndex, m_MsgCurrent.wIndex, m_MsgCurrent.OilError.dwShotCount);
	}
	else
		CtmSarmRecordFileControl::GetInstance()->ReadRecord(ID_ERROR_SRAMFILE, nIndex + 1, &m_MsgCurrent);
	
	return &m_MsgCurrent;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Error::GetErrorLogCount()			  	     		 |
|  Task     : Get Error log	Count					     	                 |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:                           -                         			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
WORD        CtmControl_Error::GetErrorLogCount()
{
	return	m_MsgIndex.wCount;
}

/*---------------------------------------------------------------------------+
|  Function : CtmControl_Error::Init_ErrorLog()				  	     		 |
|  Task     : InitError log						     	                     |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:                           -                         			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
void		CtmControl_Error::Init_ErrorLog()
{
	pthread_mutex_init(&m_MutexErrMsg, NULL);
	
	if(CtmConfig::GetInstance()->GetRecordType() == 1)
	{
		tmFileRecordHeadInfo	HeadInfo;
		if (!CManageFile::GetInstance()->CheckData(FILE_RECORD_ALARM))
		{
			memset(&HeadInfo, 0, sizeof(HeadInfo));
			memset(&m_MsgIndex, 0, sizeof(m_MsgIndex));
			CManageFile::GetInstance()->WriteRecord(FILE_RECORD_ALARM, 0, &HeadInfo, sizeof(HeadInfo)); 
		}
		else
		{
			memset(&HeadInfo, 0, sizeof(HeadInfo));
			CManageFile::GetInstance()->ReadRecord(FILE_RECORD_ALARM, 0, &HeadInfo, sizeof(HeadInfo));
			m_MsgIndex.wCount 	= HeadInfo.nCount;
			m_MsgIndex.wIndex	= HeadInfo.nIndex;
		}
	}
	else
	{
		if (!CtmSarmRecordFileControl::GetInstance()->CheckData(ID_ERROR_SRAMFILE))
		{
			memset(&m_MsgIndex, 0, sizeof(tmDB_ERROR));
			CtmSarmRecordFileControl::GetInstance()->WriteRecord(ID_ERROR_SRAMFILE, 0, &m_MsgIndex); 
		}
		else
		{
			CtmSarmRecordFileControl::GetInstance()->ReadRecord(ID_ERROR_SRAMFILE, 0, &m_MsgIndex);
		}
	}
}
/*---------------------------------------------------------------------------+
|  Function : CtmControl_Error::BackupErrorLog()				  	     		 |
|  Task     : Backup Error log						     	                     |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:                           -                         			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
void	CtmControl_Error::BackupErrorLog()		//Mario add
{
	//if(m_MsgIndex.wCount <= 0) return;
	FILE *ErrorLogFile = NULL;
	tmDB_ERROR*	pErrorMsg;
	
	ErrorLogFile = fopen("./temp/Error.log","w");
	fwrite(&m_MsgIndex, sizeof(m_MsgIndex) , 1, ErrorLogFile);
	
	for(int ErrorIndex = m_MsgIndex.wCount ; ErrorIndex >= 1 ; ErrorIndex-- )
	{
		pErrorMsg = (tmDB_ERROR*)GetErrorLog(ErrorIndex);
	}
	
	fclose( ErrorLogFile );
	/*
	for(int ErrorIndex = 1 ; ErrorIndex <= m_MsgIndex.wCount ; ErrorIndex++ )
	{
		pErrorMsg = GetErrorLog(ErrorIndex);
		
	}
	fprintf(fp, " SERVO_%03d Value=%d\n",wParaNo,GetDBValue(i).lValue);	
	*/
	
	
}
/*---------------------------------------------------------------------------+
|  Function : CtmControl_Error::RevertErrorLog()				  	     		 |
|  Task     : Revert Error log						     	                     |
+----------------------------------------------------------------------------+
|  Call     :                                                                |
|                                                                            |
|  Parameter:                           -                         			 |
|                                                                            |
|  Return   :                           -                                    |
+---------------------------------------------------------------------------*/
void	CtmControl_Error::RevertErrorLog()		//Mario add
{
	pthread_mutex_lock(&m_MutexErrMsg);
	FILE *ErrorLogFile = NULL;
	tmDB_ERROR	pErrorMsg;
	
	ErrorLogFile = fopen("./temp/Error.log","r");
	fread(&m_MsgIndex, sizeof(m_MsgIndex) , 1, ErrorLogFile);
	
	CtmSarmRecordFileControl::GetInstance()->WriteRecord(ID_ERROR_SRAMFILE,0, &m_MsgIndex);
	
	for(int ErrorIndex = 1 ; ErrorIndex <= m_MsgIndex.wCount ; ErrorIndex++ )
	{
		//pErrorMsg = GetErrorLog(ErrorIndex);
		fread(&pErrorMsg, sizeof(tmDB_ERROR) , 1, ErrorLogFile);
		printf("123\n");
		printf("ErrorIndex is %d\n",ErrorIndex);
		printf("wID is %d\n",pErrorMsg.OilError.dwID);
		CtmSarmRecordFileControl::GetInstance()->WriteRecord(ID_ERROR_SRAMFILE , ErrorIndex, &pErrorMsg);
	}
	fclose( ErrorLogFile );
	pthread_mutex_unlock(&m_MutexErrMsg);
}


#ifndef	D_BEOBJECT_CTMCONTROL_ERROR
CObject*	CreateInstance(char* Name)
{
	CObject*	pResult = Create(Name);
	if (pResult != NULL)
	{
		(static_cast<CtmPackClass*>(pResult))->CreateSelf();
	}
	return pResult;
}

void	ReleaseInstance(CObject* pInstance)
{
	if (pInstance != NULL)
		(static_cast<CtmPackClass*>(pInstance))->FreeSelf();
	delete pInstance;
	pInstance = NULL;
}

#endif
