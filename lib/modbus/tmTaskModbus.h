/**	Created by J.Wong*	2016/2/25 15:05:18*//**	Function:负责和辅机进行通信*	协议:MODBUS*	校验码:CRC16-RTU*	端口:COM2*	波特率:B9600*	校验位:NONE*	数据位:8bits*	停止位:1bit*	主机地址:*	模温机: 1-6* 	冷水机: 7-8*	吸料机: 9-10*	干燥机: 11-12*	称重搅拌机: 13-14**	数据地址：BASEADDR+ADDR**/#ifndef D_TMTASKMODBUS_H#define D_TMTASKMODBUS_H#ifdef DJSON#include <libjson/libjson.h>#endif#include "../../mb.h"#include "../../taskmodbus.h"//存储数据的文件大小#define		MODBUS_DATA_BASE_ADDR0			0#define		MODBUS_DATA_BASE_ADDR1			1000#define		MODBUS_DATA_BASE_ADDR2			2000#define		MODBUS_DATA_BASE_ADDR3			3000#define		MODBUS_DATA_BASE_ADDR4			4000#define		MODBUS_READ_COILS_CODE            	0x01   //读线圈#define		MODBUS_READ_DISCRETE_INPUTS_CODE    0x02   //读离散输入#define		MODBUS_READ_REGISTERS_CODE			0x03   //读保持寄存器数据#define		MODBUS_READ_INPUT_REGISTERS_CODE  	0x04   //读输入寄存器数据#define		MODBUS_WRITE_SINGLE_COIL_CODE     	0x05   //写单个线圈#define		MODBUS_WRITE_REGISTER_CODE			0x06   //写单个数据#define		MODBUS_READ_EXCEPTION_STATUS_CODE   0x07#define		MODBUS_WRITE_MULTIPLE_COILS_CODE    0x0F   //写多个线圈#define		MODBUS_WRITE_REGISTERS_CODE			0x10   //写多个保持寄存器数据#define		MODBUS_REPORT_SLAVE_ID_CODE     0x11#define		MODBUS_MASK_WRITE_REGISTER_CODE     0x16   //通过掩码值操作寄存器写#define		MODBUS_WRITE_AND_READ_REGISERS_CODE 0x17   //读写寄存器同时操作#define		MAX_HOST_ADDR_COUNT				0x10/**count	连续的地址数*host	主机地址*addr	起始读寄存器地址*/typedef	struct {	int slave;	int func;	int reg;	int count;	int attr;}__attribute__((packed, aligned(2)))modbus_data_mapping_t;class CtmTaskModbus:public CTaskModbus{	DECLARE_DYNCREATE(CtmTaskModbus)	public:		CtmTaskModbus();		~CtmTaskModbus();		int 	CreateSelf();		int 	FreeSelf();				/*read and write by configuration database */		virtual 	void	Read(char* 	read_id);		virtual		void 	Write(char* write_id, WORD wFunc =0);		virtual		void	ReadWrite(char* write_id, char* read_id);		/*read and write by registers*/			virtual		void	Read(int slave, int func, int start_addr,	int nr);		virtual		void	Write(int slave, int func, int start_addr, void* src,  int nr);		virtual		void	ReadWrite(int slave, int func,int write_addr,void* src,int write_nr,int read_addr,int read_nr);				virtual		int		GetData(int slave,int start_addr,void* dest, int nr);		virtual		void	Run();	private:			virtual		void*	Merbromin(void* param);	private:		class CtmPrivateData;  		CtmPrivateData* m_data;  		#ifdef DJSON  		void  ParseJsonTCP(JSONNode header,modbus_tcp_t& tcp);		void  ParseJsonRTU(JSONNode header,modbus_rtu_t& rtu);		void  ParseJson(const std::string file);		const modbus_data_mapping_t ParseJsonChild(JSONNode child);		#else  		void	OpenXmlFile(char* xmlFile=0);  		void	CloseXmlFile();  		void	ParseXml();  		void 	ParseComponent(xmlDocPtr doc, xmlNsPtr ns, xmlNodePtr cur);  		#endif		};void 	Task(uint8_t slave, uint16_t func, uint16_t start_addr, void* rsp,int nr);#ifndef	D_BEOBJECT_CTMTASKMODBUS	//	defineName=D_BEOBJECT_+CASE(ClassName)extern	"C"	CObject*	CreateInstance(char* Name);extern	"C"	void		ReleaseInstance(CObject* pInstance);#endif#endif