#include "drawtext.h"#include <string>////extern unsigned int* g_row[600];static bool check_identifer_domain(int unicode){	return ((unicode>=0x0020&&unicode<=0x002F)||		(unicode>=0x003A&&unicode<=0x0040)||		(unicode>=0x005B&&unicode<=0x0060)||		(unicode>=0x007B&&unicode<=0x007E)||		(unicode>=0x00A0&&unicode<=0x00BF)||		(unicode>=0x2000&&unicode<=0x206F)||		(unicode>=0x2E00&&unicode<=0x2E7F)||		(unicode>=0x3000&&unicode<=0x303F)||		(unicode>=0xFF01&&unicode<=0xFF0F)||		(unicode>=0xFF1A&&unicode<=0xFF20)||		(unicode>=0xFF3B&&unicode<=0xFF40)||		(unicode>=0xFF5B&&unicode<=0xFF5E));	}CtmDrawText*	g_pDrawText;CtmDrawText::CtmDrawText(){    m_pFTLib=NULL;    m_pFTFace=NULL;    m_error=0;    m_pszFontFile=NULL;    m_enCoding=FT_ENCODING_UNICODE;    m_glyph=NULL;    m_nHeight=    m_nWidth=16;    m_matrix.xx = (FT_Fixed)(cos(0) * 0x10000L );    m_matrix.xy = (FT_Fixed)(-sin(0) * 0x10000L );    m_matrix.yx = (FT_Fixed)( sin(0) * 0x10000L );    m_matrix.yy = (FT_Fixed)( cos(0) * 0x10000L );    m_nAscender=0;    m_nTop=0;    m_nSlotHeight=0;    m_nFontColor=0;    m_nBgcColor=0xFFFFFF;    m_fConva=0.0;    m_nAngle=0;    m_nUnicodeCount=-1;	m_cache= new FontCache;	m_nOffsetHalfWidth =0;	m_nTotalWidth=0;	m_nOffset=0;    Init();}CtmDrawText::CtmDrawText(const char *pszFontFile){    m_pFTLib=NULL;    m_pFTFace=NULL;    m_error=0;    m_pszFontFile=NULL;    m_enCoding=FT_ENCODING_UNICODE;    m_glyph=NULL;    m_nHeight=    m_nWidth=16;    m_matrix.xx = (FT_Fixed)(cos(0) * 0x10000L );    m_matrix.xy = (FT_Fixed)(-sin(0) * 0x10000L );    m_matrix.yx = (FT_Fixed)( sin(0) * 0x10000L );    m_matrix.yy = (FT_Fixed)( cos(0) * 0x10000L );    m_nAscender=0;    m_nTop=0;    m_nSlotHeight=0;    m_nFontColor=0;    m_nBgcColor=0xFFFFFF; 	m_fConva=0.0;    m_nAngle=0;    m_nOffsetHalfWidth=0;    m_nTotalWidth=0;    m_nOffset =0;	m_nUnicodeCount= -1;    m_cache= new FontCache;    Init();    LoadFontFace(pszFontFile);}CtmDrawText::~CtmDrawText(){    FreeFontFace();    if(m_pszFontFile!=NULL)    {       delete m_pszFontFile;        m_pszFontFile=NULL;    }    Free();    if(m_cache)    {    	delete m_cache;    	m_cache=NULL;	    }}void CtmDrawText::Free(){    FT_Done_FreeType(m_pFTLib);    m_pFTLib  =  NULL;}FT_Error CtmDrawText::Init(){    m_error  =  FT_Init_FreeType( & m_pFTLib);    if (m_error)    {        m_pFTLib  =   NULL ;        printf( " There is some error when Init Library " );        return   -1 ;    }   return m_error;}void CtmDrawText::FreeFontFace(){	if(m_pFTFace)    	FT_Done_Face(m_pFTFace);    m_pFTFace  =  NULL;}FT_Error CtmDrawText::LoadFontFace(const char *pszFontFile){   if(m_pszFontFile!=NULL)   {       delete m_pszFontFile;       m_pszFontFile=NULL;   }   m_pszFontFile=new char[strlen(pszFontFile)+1];   memcpy(m_pszFontFile,pszFontFile,strlen(pszFontFile)+1);   m_error = FT_New_Face(m_pFTLib,  pszFontFile ,  0 , &m_pFTFace);   return m_error;}FT_Error CtmDrawText::SetEnCoding(FT_Encoding encoding){    m_enCoding=encoding;    m_error = FT_Select_Charmap( m_pFTFace, /* 多多face多多 */ encoding );    return m_error;}FT_Error CtmDrawText::SetFontSize(FT_UInt Width, FT_UInt Height,int nAlign){    m_nHeight	= Height;    m_nWidth	= Width;    m_nAlign 	= nAlign;	if(m_nWidth==0) m_nWidth=m_nHeight;  	// if(m_nHeight<m_nWidth) m_nHeight=m_nWidth;    //m_error= FT_Set_Pixel_Sizes(m_pFTFace,Width,Height);    return 0;//m_error;}void CtmDrawText::SetFontAngle(int angle){	int co=0;	co=angle/360;	m_nAngle=angle;	angle=-angle;	if(co==0)	m_fConva=(angle*2*PI)/360.0;	else		m_fConva=((angle%360)*2*PI)/360.0;	//printf("m_fConva=%lf\n",m_fConva);    m_matrix.xx = (FT_Fixed)(cos(m_fConva) * 0x10000L );    m_matrix.xy = (FT_Fixed)(-sin(m_fConva) * 0x10000L );    m_matrix.yx = (FT_Fixed)( sin(m_fConva) * 0x10000L );    m_matrix.yy = (FT_Fixed)( cos(m_fConva) * 0x10000L );    FT_Set_Transform(m_pFTFace,&m_matrix,NULL);    return;}void CtmDrawText::SetFontColor(unsigned int color){    m_nFontColor=color;}void CtmDrawText::SetBgcColor(unsigned int color){    m_nBgcColor=color;}int				CtmDrawText::GetFontWidth(unsigned int* pdwCode){	int nLen=0;	SIZE size;	size.width=m_nWidth;	size.height=m_nHeight;	if(*pdwCode!=0)	{		Glyph*	FontItem=GetGlyph(*pdwCode, size);		if(FontItem)		{								TMMATRICS matrics=FontItem->GetMatrics();			int nWidth=matrics.horibearingX+FontItem->GetBitmapWidth();			if(*pdwCode==0x20)			{				nWidth=m_nWidth/2;				}			else			if(check_identifer_domain(*pdwCode))	        {	        	nWidth=m_nWidth/2;	        }			nLen+=nWidth;		}	}	return nLen;}int				CtmDrawText::GetFontWidth(unsigned char* cCode,SIZE size){	int nLen=0;	if(*cCode!=0)	{		Glyph*	FontItem=GetGlyph(*cCode, size);		if(FontItem)		{								TMMATRICS matrics=FontItem->GetMatrics();			int nWidth=matrics.horibearingX+FontItem->GetBitmapWidth();			if(*cCode==0x20)			{				nWidth=m_nWidth/2;				}			else			if(*cCode<0x41)	       	{		      	if(nWidth<=size.width/2)	nWidth=size.width/2;		    }			else			if(check_identifer_domain(*cCode))	        {	        	nWidth=m_nWidth/2;	        }			nLen+=nWidth;		}	}	return nLen;}CPoint 	CtmDrawText::GetCharPosition(unsigned char* cCode, int uLen, unsigned char cKey,SIZE size,CRect rect,unsigned short wAlign, int offset_bytes){	int nStartX=0;	int nStartY=0;	int nEndX=rect.right();	int nEndY=rect.bottom();	int rWidth=rect.width();	int rHeight=rect.height();	int nOffset_Bytes=0;	if(nStartX<0) nStartX=-nStartX;    if(nStartY<0) nStartY=-nStartY;    int nLength=0;    nLength=GetTextLength(cCode,size,uLen);    if(offset_bytes>0)    {    	nOffset_Bytes=GetTextLength(cCode+uLen-offset_bytes,size,offset_bytes);    }    int offset=0;    if((wAlign&0x01)==0x01)    {    	//left    	nLength-=nOffset_Bytes;    	offset=nLength-GetFontWidth(&cKey,size);    }    else if((wAlign&0x02)==0x02)    {    	//center    	int nTemp=rWidth-nLength;    	if(nTemp<0)		nStartX=0;    	else			nStartX=nTemp>>1;    	int halfWidth=GetFontWidth(&cKey,size);    	offset=(nLength-halfWidth-nOffset_Bytes);    }    else if((wAlign&0x04)==0x04)    {    	//right    	nStartX=rWidth-nLength-1;    	if(nStartX<0)	nStartX=0;    	offset=nLength-GetFontWidth(&cKey,size)-nOffset_Bytes;    }	nStartX+=rect.left();	nStartY+=rect.top();	if(cKey!=0)	{		nStartX+=offset;		}	return CPoint(nStartX,nStartY);}int			CtmDrawText::GetTextLength(unsigned char* cCode, SIZE size, int uLen){	int nLen=0;	if(uLen>=0)	{		for(int i=0; i<uLen; ++i)		{			if(*cCode!=0)			{				unsigned int dwCode=*cCode;				Glyph*	FontItem=GetGlyph(dwCode, size);				if(FontItem)				{											TMMATRICS matrics=FontItem->GetMatrics();					int nWidth=matrics.horibearingX+FontItem->GetBitmapWidth();					if(dwCode==0x20) nLen+=m_nWidth/2;					if(dwCode<0x41)	       			{		      			if(nWidth<=size.width/2)	nWidth=size.width/2;		      		}		        	nLen+=nWidth;				}				cCode++;				}		}	}	else	{		while(*cCode!=0)		{			unsigned int dwCode=*cCode;			Glyph*	FontItem=GetGlyph(dwCode, size);			if(FontItem)			{									TMMATRICS matrics=FontItem->GetMatrics();				int nWidth=matrics.horibearingX+FontItem->GetBitmapWidth();				if(dwCode==0x20) nLen+=m_nWidth/2;				if(dwCode<0x41)       			{	      			if(nWidth<=m_nWidth/2)	nWidth=m_nWidth/2;	      		}	        	nLen+=nWidth;			}			cCode++;			}	}	return nLen;}int		CtmDrawText::GetTextLength(unsigned char* cCode, int uLen){	int nLen=0;	SIZE size;	size.width=m_nWidth;	size.height=m_nHeight;	while(*cCode!=0)	{			unsigned int dwCode=*cCode;			Glyph*	FontItem=GetGlyph(dwCode, size);			if(FontItem)			{									TMMATRICS matrics=FontItem->GetMatrics();				int nWidth=matrics.horibearingX+FontItem->GetBitmapWidth();				if(dwCode==0x20) nLen+=m_nWidth/2;				if(dwCode<0x41)       			{	      			if(nWidth<=m_nWidth/2)	nWidth=m_nWidth/2;	      		}	        	nLen+=nWidth;			}			cCode++;		}	return nLen;}int		CtmDrawText::GetTextLength(unsigned int* dwCode, int uLen){	int nLen=0;	SIZE size;	size.width=m_nWidth;	size.height=m_nHeight;	if(m_nUnicodeCount==-1)	{		while(*dwCode!=0)		{			Glyph*	FontItem=GetGlyph(*dwCode, size);			if(FontItem)			{									TMMATRICS matrics=FontItem->GetMatrics();				int nWidth=matrics.horibearingX+FontItem->GetBitmapWidth();//				printf("*dwCode=%x,bitWidth:%d\n",*dwCode,nWidth);					if(*dwCode==0x20) nLen+=m_nWidth/2;				if(*dwCode<0x41)				{	        		if(nWidth<=m_nWidth/2)	nWidth=m_nWidth/2;	        	}	        	nLen+=nWidth;			}			dwCode++;			}	}	else	{		for(int i=0; i<m_nUnicodeCount; i++)		{			if(dwCode[i]!=0)			{				Glyph*	FontItem=GetGlyph(dwCode[i], size);				if(FontItem)				{										TMMATRICS matrics=FontItem->GetMatrics();					int nWidth=matrics.horibearingX+FontItem->GetBitmapWidth();					//printf("*dwCode=%x,bitWidth:%d\n",dwCode[i],nWidth);						if(dwCode[i]==0x20) nLen+=m_nWidth/2;					else if(dwCode[i]<0x41)		     		{	        			if(nWidth<=m_nWidth/2)	 nWidth=m_nWidth/2;	        		}						        		nLen+=nWidth;					}				else				{					break;				}			}			}		}	return nLen;	}#ifdef	D_32BITvoid CtmDrawText::DrawText(unsigned long** pSource,unsigned short *pwCode, int nStartX, int nStartY,int nEndX, int nEndY, int angle, int flag, int nLen)#elsevoid CtmDrawText::DrawText(unsigned short** pSource,unsigned short *pwCode, int nStartX, int nStartY,int nEndX, int nEndY, int angle, int flag, int nLen)#endif{    if(nStartX<0) nStartX=-nStartX;    if(nStartY<0) nStartY=-nStartY;    while(*pwCode!=0)    {		if(*pwCode!=0x20)		{      	 		int width= DrawWord(pSource,*pwCode,nStartX, nStartY,nEndX, nEndY,angle,flag);        		pwCode++;//        		if((*pwCode&0x80)==0x0)//        		{//        			nStartX+=width;//        		}//        		else//        		{        			nStartX+=m_nWidth;//        		}        }        else        {        		pwCode++;        		nStartX+=m_nWidth/2;        }    }}#ifdef	D_32BITvoid CtmDrawText::DrawText(unsigned long** pSource,unsigned int *pdwCode, int nStartX, int nStartY,int nEndX, int nEndY, int angle, int flag, int nLen)#elsevoid CtmDrawText::DrawText(unsigned short** pSource,unsigned int *pdwCode, int nStartX, int nStartY,int nEndX, int nEndY, int angle, int flag, int nLen)#endif{	if(nStartX<0) nStartX=-nStartX;    if(nStartY<0) nStartY=-nStartY;    m_nUnicodeCount	=nLen;    int nLength	  =GetTextLength(pdwCode);    m_nUnicodeCount=-1;    if(nLength<=0)    {	    	ResetHorizontalOffset();    	return;    }    //printf("m_nAlign=%d\n",m_nAlign);    if((m_nAlign&0x01)==0x01)    {    	//left    	;    }    else if((m_nAlign&0x02)==0x02)    {    	//center    	int nTemp=nEndX-nLength+2;    	if(nTemp<0)		nStartX=0;    	else			nStartX=nTemp>>1;    }    else if((m_nAlign&0x04)==0x04)    {    	//right    	nStartX=nEndX-nLength-2;    	if(nStartX<0)	nStartX=0;		    }        int nOriginX=nStartX;    int nOriginY=nStartY;    //printf("nStartX=%d,nStartY=%d\n",nStartX,nStartY);    if(nLen == -1)    {	    while(*pdwCode!=0)	    {	    				if(*pdwCode!=0x20)			{				if(*pdwCode=='\n')				{					nStartX=nOriginX;					//nStartY+=(m_nHeight*5/4);					pdwCode++;					continue;				}	       		int width= DrawWord(pSource,*pdwCode,nStartX, nStartY,nEndX, nEndY,angle,flag);	     	 	if(m_nOffset<0)	continue;	     	 	if(*pdwCode<0x41)     			{	      			if(width<=m_nWidth/2)	width=m_nWidth/2;  		        	}				if(check_identifer_domain(*pdwCode))	        	{	        		nStartX+=m_nWidth/2;		        	}				else	        		nStartX+=width;	        	pdwCode++;	        }	        else	        {	        	pdwCode++;	        		        	//if(m_nOffset<0)	continue;	        	nStartX+=m_nWidth/2;	        		        			        }	    }	}	else	{				for(int i = 0; i < nLen; i++)		{			if(*(pdwCode+i)!=0x20)			{				if(*(pdwCode+i)=='\n')				{					nStartX=nOriginX;					nStartY+=(m_nHeight*5/4);					continue;				}	       		int width= DrawWord(pSource,*(pdwCode+i),nStartX, nStartY,nEndX, nEndY,angle,flag);	        	if(m_nOffset<0)	continue;	        	if(*(pdwCode+i)<0x41)     		        	{        			if(width<=m_nWidth/2)	width=m_nWidth/2;        		}        	    nStartX+=width;	        }	        else	        {	        	//if(m_nOffset<0)	continue;	        	nStartX+=m_nWidth/2;		        }		}		}	ResetHorizontalOffset();}#ifdef	D_32BITvoid	CtmDrawText::DrawText(unsigned long** pSource,unsigned char* pcCode,int nStartX, int nStartY,int nEndX, int nEndY,int angle, int flag, int nLen)#elsevoid	CtmDrawText::DrawText(unsigned short** pSource,unsigned char* pcCode,int nStartX, int nStartY,int nEndX, int nEndY,int angle, int flag, int nLen)#endif{	if(nStartX<0) nStartX=-nStartX;    	if(nStartY<0) nStartY=-nStartY;    while(*pcCode!=0)    {		if(*pcCode!=0x20)		{       			int width= DrawWord(pSource,*pcCode,nStartX, nStartY,nEndX,nEndY,angle,flag);        		pcCode++;        		if(m_nOffset<0)	continue;        		nStartX+=width;        }        else       	{        		pcCode++;        		if(m_nOffset<0)	continue;        		nStartX+=m_nWidth/2;	        }   	 }}#ifdef	D_32BITvoid			CtmDrawText::DrawText(CImage& image, unsigned char* pcCode, CRect rect, int nLen){	int nStartX=0;	int nStartY=0;	int nEndX=rect.right();	int nEndY=rect.bottom();	int rWidth=rect.width();	int rHeight=rect.height();		if(nStartX<0) nStartX=-nStartX;    if(nStartY<0) nStartY=-nStartY;    m_nUnicodeCount=-1;    int nLength	  =GetTextLength(pcCode);    if(nLength<=0)    {	    	ResetHorizontalOffset();    	return;    }    if((m_nAlign&0x01)==0x01)    {    	//left    	;    }    else if((m_nAlign&0x02)==0x02)    {    	//center    	int nTemp=rWidth-nLength;    	if(nTemp<0)		nStartX=0;    	else			nStartX=nTemp>>1;    }    else if((m_nAlign&0x04)==0x04)    {    	//right    	nStartX=rWidth-nLength-1;    	if(nStartX<0)	nStartX=0;		    }    nStartX+=rect.left();	nStartY+=rect.top();		for(int i=0; i<nLen; ++i)	{		if(*pcCode!=0x20)		{       			int width= DrawWord(image,*pcCode,nStartX, nStartY,nEndX,nEndY,0,1);        		pcCode++;        		if(m_nOffset<0)	continue;      		if(*pcCode<0x41)   			{	       		if(width<=m_nWidth/2)	width=m_nWidth/2;	       	}	        nStartX+=width;        }        else       	{        		pcCode++;        		if(m_nOffset<0)	continue;        		nStartX+=m_nWidth/2;	        }		}}void			CtmDrawText::DrawText(CImage& image, unsigned int* pwCode, CRect rect, int nLen){	int nStartX=0;	int nStartY=0;	int nEndX=rect.right();	int nEndY=rect.bottom();	int rWidth=rect.width();	int rHeight=rect.height();		if(nStartX<0) nStartX=-nStartX;    if(nStartY<0) nStartY=-nStartY;    m_nUnicodeCount=-1;    int nLength	  =GetTextLength(pwCode);    if(nLength<=0)    {	    	ResetHorizontalOffset();    	return;    }    if((m_nAlign&0x01)==0x01)    {    	//left    	;    }    else if((m_nAlign&0x02)==0x02)    {    	//center    	int nTemp=rWidth-nLength;    	if(nTemp<0)		nStartX=0;    	else			nStartX=nTemp>>1;    }    else if((m_nAlign&0x04)==0x04)    {    	//right    	nStartX=rWidth-nLength-1;    	if(nStartX<0)	nStartX=0;		    }    nStartX+=rect.left();	nStartY+=rect.top();		for(int i=0; i<nLen; ++i)	{		if(*pwCode!=0x20)		{       			int width= DrawWord(image,*pwCode,nStartX, nStartY,nEndX,nEndY,0,1);        		pwCode++;        		if(m_nOffset<0)	continue;      		if(*pwCode<0x41)   			{	       		if(width<=m_nWidth/2)	width=m_nWidth/2;	       	}	        nStartX+=width;        }        else       	{        		pwCode++;        		if(m_nOffset<0)	continue;        		nStartX+=m_nWidth/2;	        }		}}unsigned int  	CtmDrawText::DrawWord(CImage& image,unsigned int dwCode, int nStartX, int nStartY, int nEndX, int nEndY, int angle, int flag){	unsigned int width=0;    SetFontAngle(angle);    SIZE size;    size.width=m_nWidth;    size.height=m_nHeight;    Glyph*	FontItem=GetGlyph(dwCode, size);    if(FontItem)    {    	   m_matrics=FontItem->GetMatrics();    	   m_nBitmap.buffer=FontItem->GetBitmapBuffer();    	   m_nBitmap.width=FontItem->GetBitmapWidth();    	   m_nBitmap.rows=FontItem->GetBitmapHeight();           int nBearingY=m_matrics.horibearingY;           int Ascender=m_matrics.ascender;           int nHoriAdvance=m_matrics.horiadvance;           int nHoriBearingX=m_matrics.horibearingX;                     width=nHoriBearingX+m_nBitmap.width;           if(m_nOffset<0)           {	           if(m_nOffsetHalfWidth-m_nTotalWidth>0)			   {			   				   			m_nTotalWidth+=m_nWidth/2; 			   		return 0;				   }			   else			   {			   		m_nOffset=m_nTotalWidth-m_nOffsetHalfWidth;			   }		   }           nStartX+=nHoriBearingX;           int FR=(m_nFontColor&0xFF0000)>>16;           int FG=(m_nFontColor&0xFF00)>>8;           int FB=(m_nFontColor&0xFF);             int BR=(m_nBgcColor&0xFF0000)>>16;           int BG=(m_nBgcColor&0xFF00)>>8;           int BB=(m_nBgcColor&0xFF);                  nStartY+=Ascender-nBearingY;           if(nStartY<0)	nStartY=0;           for(int i=0; i<m_nBitmap.rows;++i)           {           	  if((i+nStartY)>=nEndY)	break;              	for(int j=m_nOffset; j<m_nBitmap.width;++j)              	{              	  	if((j+nStartX)>=nEndX)	break;              	  	if(m_nBitmap.buffer[i * m_nBitmap.width + j])              	  	{              	  		int alpha=m_nBitmap.buffer[i * m_nBitmap.width + j];              	  		if(flag==1)              	  		{             				 BR=(image.pixel(j+nStartX,i+nStartY)&0xFF0000)>>16;           					 BG=(image.pixel(j+nStartX,i+nStartY)&0xFF00)>>8;           					 BB=(image.pixel(j+nStartX,i+nStartY)&0xFF);              	  		}                                 		int fontcolor=RGB2PIXEL888((BR*(0xFF-alpha)+(FR*alpha))>>8,                   									(BG*(0xFF-alpha)+(FG*alpha))>>8,                   									(BB*(0xFF-alpha)+(FB*alpha))>>8);                   		image.setPixel(j+nStartX,i+nStartY,fontcolor);                  	}                  	else                  	{                  		;                  	}              	}           }           m_nOffset=0;    }    else        return 0;   return width;	}#endif#ifdef	D_32BITunsigned int  CtmDrawText::DrawWord(unsigned long** pSource,unsigned int dwCode, int nStartX, int nStartY, int nEndX, int nEndY, int angle, int flag)#elseunsigned int  CtmDrawText::DrawWord(unsigned short** pSource,unsigned int dwCode, int nStartX, int nStartY, int nEndX, int nEndY, int angle, int flag)#endif{	unsigned int width=0;    SetFontAngle(angle);    SIZE size;    size.width=m_nWidth;    size.height=m_nHeight;    Glyph*	FontItem=GetGlyph(dwCode, size);    if(FontItem)    {    	   m_matrics=FontItem->GetMatrics();    	   m_nBitmap.buffer=FontItem->GetBitmapBuffer();    	   m_nBitmap.width=FontItem->GetBitmapWidth();    	   m_nBitmap.rows=FontItem->GetBitmapHeight();           int nBearingY=m_matrics.horibearingY;           int Ascender=m_matrics.ascender;           int nHoriAdvance=m_matrics.horiadvance;           int nHoriBearingX=m_matrics.horibearingX;           /*int nWidth=m_matrics.width;*/                     width=nHoriBearingX+m_nBitmap.width/*+nWidth*/;           if(m_nOffset<0)           {	           if(m_nOffsetHalfWidth-m_nTotalWidth>0)			   {			   				   			m_nTotalWidth+=m_nWidth/2; 			   		return 0;				   }			   else			   {			   		m_nOffset=m_nTotalWidth-m_nOffsetHalfWidth;			   }		   }           nStartX+=nHoriBearingX;           //printf("nWidth=%d,width=%d,%d,%d,%d,%d\n",nWidth,width,nBearingY,Ascender,nHoriAdvance,nHoriBearingX);           //printf("nHoriAdvance=%d,nHoriBearingX=%d,nWidth=%d,width=%d\n",nHoriAdvance,nHoriBearingX,nWidth,width);           //xAdvance=(m_pFTFace->glyph->metrics).horiAdvance>>6;           #ifdef D_32BIT           int FR=(m_nFontColor&0xFF0000)>>16;           int FG=(m_nFontColor&0xFF00)>>8;           int FB=(m_nFontColor&0xFF);           #else           int FR=(m_nFontColor & 0xF800)	>> 8;           int FG=(m_nFontColor & 0x7E0)	>> 3;           int FB=(m_nFontColor & 0x1F) 	<< 3;           #endif           //float nPerR=(R-(int)((m_nBgcColor&0x00FF0000)>>16))/255.0;           //float nPerG=(G-(int)((m_nBgcColor&0x00FF00)>>8))/255.0;           //float nPerB=(B-(int)(m_nBgcColor&0x00FF))/255.0;           #ifdef D_32BIT           int BR=(m_nBgcColor&0xFF0000)>>16;           int BG=(m_nBgcColor&0xFF00)>>8;           int BB=(m_nBgcColor&0xFF);           #else           int BR=(m_nBgcColor & 0xF800)	>> 8;              int BG=(m_nBgcColor & 0x7E0)	>> 3;              int BB=(m_nBgcColor & 0x1F) 	<< 3;              #endif           //printf("m_nBgcColor=%x m_nFontColor=%x \n", m_nBgcColor, m_nFontColor);           //printf("<%d,%d>\n",nStartX,nStartY+Ascender-nBearingY);           // printf("m_nBitmap.rows=%d,m_nBitmap.width=%d\n",m_nBitmap.rows,m_nBitmap.width);           nStartY+=Ascender-nBearingY;           if(nStartY<0)	nStartY=0;           for(int i=0; i<m_nBitmap.rows;++i)           {             //printf("start y=%d,end y=%d\n",i+nStartY+Ascender-nBearingY,nEndY);           	  if((i+nStartY)>=nEndY)	break;              	for(int j=m_nOffset; j<m_nBitmap.width;++j)              	{              		//printf("j+nStartX=%d\n",j+nStartX);              	  	if((j+nStartX)>=nEndX)	break;              	  	if(m_nBitmap.buffer[i * m_nBitmap.width + j])              	  	{              	  		int alpha=m_nBitmap.buffer[i * m_nBitmap.width + j];              	  		if(flag==1)              	  		{              	  			//nPerR=(R-(int)((pSource[i+nStartY+Ascender-nBearingY][j+nStartX]&0x00FF0000)>>16))/255.0;             				//nPerG=(G-(int)((pSource[i+nStartY+Ascender-nBearingY][j+nStartX]&0x00FF00)>>8))/255.0;             				//nPerB=(B-(int)(pSource[i+nStartY+Ascender-nBearingY][j+nStartX]&0x00FF))/255.0;             				 #ifdef	D_32BIT             				 BR=(pSource[i+nStartY][j+nStartX]&0xFF0000)>>16;           					 BG=(pSource[i+nStartY][j+nStartX]&0xFF00)>>8;           					 BB=(pSource[i+nStartY][j+nStartX]&0xFF);           					 #else           					 BR=(pSource[i+nStartY][j+nStartX] & 0xF800)	>> 8;                     					 BG=(pSource[i+nStartY][j+nStartX] & 0x7E0)	>> 3;                     					 BB=(pSource[i+nStartY][j+nStartX] & 0x1F) 	<< 3;                     					 #endif              	  		}              	  		//int IncR=nPerR*((int)(0xFF-(unsigned short)m_nBitmap.buffer[i * m_nBitmap.width + j]));              	  		//int IncG=nPerG*((int)(0xFF-(unsigned short)m_nBitmap.buffer[i * m_nBitmap.width + j]));              	  		//int IncB=nPerB*((int)(0xFF-m_nBitmap.buffer[i * m_nBitmap.width + j]));                        //int fontcolor=RGB2PIXEL888(IncR>=0?(R-IncR):(R+(0xFF-IncR)),IncG>=0?(G-IncG):(G+(0xFF-IncG)),IncB>=0?(B-IncB):(B+(0xFF-IncB)));                   		//if(alpha < 128)                   		//	alpha +=64;                   		#ifdef	D_32BIT                   		int fontcolor=RGB2PIXEL888((BR*(0xFF-alpha)+(FR*alpha))>>8,                   									(BG*(0xFF-alpha)+(FG*alpha))>>8,                   									(BB*(0xFF-alpha)+(FB*alpha))>>8);                   		#else                   		int fontcolor=RGB2PIXEL565((BR*(0xFF-alpha)+(FR*alpha))>>8,                   									(BG*(0xFF-alpha)+(FG*alpha))>>8,                   									(BB*(0xFF-alpha)+(FB*alpha))>>8);                   		#endif                   		pSource[i+nStartY][j+nStartX]=fontcolor;                  	}                  	else                  	{                  		;//pSource[i+nStartY+Ascender-nBearingY][j+nStartX]=m_nBgcColor;                  	}              	}           }           m_nOffset=0;    }    else        return 0;   return width;}Glyph*	CtmDrawText::GetGlyph(unsigned int dwCode, SIZE size){	Glyph* item = m_cache->GetFontCache(dwCode, size);	if (NULL != item) return item;	FT_Set_Pixel_Sizes(m_pFTFace,size.width,size.height);	Glyph glyph;	if (!GetGlyph(dwCode, 0, glyph)) return NULL;	m_cache->AddFontCache(dwCode, size, glyph);	return GetGlyph(dwCode, size);			}bool CtmDrawText::GetGlyph(unsigned int dwCode, int size, Glyph& glyph){	int nSize=0;	if(!m_pFTFace)	return false;			FT_Load_Char( m_pFTFace,dwCode,/*FT_LOAD_RENDER);*/                        /*FT_LOAD_NO_AUTOHINT |*/ FT_LOAD_MONOCHROME|FT_LOAD_NO_BITMAP );    m_error  =  FT_Get_Glyph(m_pFTFace -> glyph,  &m_glyph);    if(m_error)		return false;    m_error|=FT_Glyph_To_Bitmap( &m_glyph, (FT_Render_Mode)0,  0 ,  1 );    if(m_error)	return false;    FT_BitmapGlyph    bitmap_glyph  =  (FT_BitmapGlyph)m_glyph;    FT_Bitmap ft_Bitmap  =  bitmap_glyph -> bitmap;    TMMATRICS	matrics;    matrics.horibearingY=(m_pFTFace->glyph->metrics).horiBearingY>>6;    matrics.ascender=m_pFTFace->size->metrics.ascender>>6;    matrics.horiadvance=(m_pFTFace->glyph->metrics).horiAdvance>>6;    matrics.horibearingX=(m_pFTFace->glyph->metrics).horiBearingX>>6;    matrics.width=(m_pFTFace->glyph->metrics).width>>6;    matrics.height=(m_pFTFace->glyph->metrics).height>>6;    glyph.SetMatrics(matrics);    glyph.SetBitmapWidth(ft_Bitmap.width);    glyph.SetBitmapHeight(ft_Bitmap.rows);    nSize=ft_Bitmap.width*ft_Bitmap.rows;    glyph.SetBimapBufferSize(nSize);    glyph.NewBitmapBuffer(nSize);    glyph.CopyToBuffer(ft_Bitmap.buffer,nSize);    FT_Done_Glyph(m_glyph);    m_glyph  =  NULL;    return true;}int	CtmDrawText::SetHorizontalOffset(int nOffsetBytes){	m_nOffset=-1;	m_nTotalWidth =0;	m_nOffsetHalfWidth=nOffsetBytes*m_nWidth/2;	return m_nOffsetHalfWidth;}int CtmDrawText::ResetHorizontalOffset(){	m_nOffset=0;	m_nOffsetHalfWidth=0;	m_nTotalWidth =0;	return m_nOffsetHalfWidth;}////////////////////////////